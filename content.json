{"posts":[{"title":"Route53とオンプレDNSにおける条件付きフォワーダーと委任の構成比較","text":"Route 53 リゾルバーのエンドポイントを使ったプライベートホストゾーンへのサブドメインの委任について、Qiita(※)で解説記事を拝見してその構成を条件付きフォワーダーと比べるとどうなるか構成図に表してみました。 これまではオンプレ環境の独自ドメインの権威 DNS サーバで管理しているドメインがあり、AWSのRoute53でサブドメインを管理したい場合、Route 53 インバウンドエンドポイントへオンプレミスからの名前解決クエリを転送する必要がありました。（条件付きフォワーダー設定） Route 53 リゾルバーのプライベートホストゾーンへのサブドメインの委任を設定することができるようになりました。 Amazon Route 53 Resolver endpoints now support DNS delegation for private hosted zones 標準的なDNS委任構成となるので、条件付きフォワーダーよりも委任設定が推奨ですが、Route 53 インバウンドエンドポイントの再作成にはネットワーク停止を伴う点は注意が必要です。 (※)Route 53 プライベートホストゾーンへオンプレミスの DNS サーバーからサブドメインを委任できるようになったので試してみた","link":"/2025/06/29/dns_forward/"},{"title":"sshdの接続元を日本のIPに限定する","text":"fetus 国／地域別IPアドレス割り振り一覧 のIPリストを取得し、SSHの接続元を日本のIPに限定 環境情報 OS Ubuntu Version 24.04.2 LTS hosts.allowとhosts.denyの設定 最終行は改行が必要です（改行がないと正常に動作しません） /etc/hosts.allow 12sshd: /etc/jp.allow /etc/hosts.deny 12ALL : ALL スクリプト必要なライブラリの取得します 1pip install requests jp_allow.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import requests# IPリストを取得するURLURL = &quot;https://ipv4.fetus.jp/jp.txt&quot;def convert_subnet(cidr_value): ''' サブネットを255.255.255.0形式に変換する関数 ''' subnet_map = { 8: &quot;255.0.0.0&quot;, 9: &quot;255.128.0.0&quot;, 10: &quot;255.192.0.0&quot;, 11: &quot;255.224.0.0&quot;, 12: &quot;255.240.0.0&quot;, 13: &quot;255.248.0.0&quot;, 14: &quot;255.252.0.0&quot;, 15: &quot;255.254.0.0&quot;, 16: &quot;255.255.0.0&quot;, 17: &quot;255.255.128.0&quot;, 18: &quot;255.255.192.0&quot;, 19: &quot;255.255.224.0&quot;, 20: &quot;255.255.240.0&quot;, 21: &quot;255.255.248.0&quot;, 22: &quot;255.255.252.0&quot;, 23: &quot;255.255.254.0&quot;, 24: &quot;255.255.255.0&quot;, 25: &quot;255.255.255.128&quot;, 26: &quot;255.255.255.192&quot;, 27: &quot;255.255.255.224&quot;, 28: &quot;255.255.255.240&quot;, 29: &quot;255.255.255.248&quot;, 30: &quot;255.255.255.252&quot;, 31: &quot;255.255.255.254&quot;, 32: &quot;255.255.255.255&quot; } return subnet_map.get(cidr_value)# URLからデータを取得response = requests.get(URL, timeout=5)ip_data = response.text.splitlines()# jp.allow形式に変換with open(&quot;/etc/jp.allow&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as file: output = [] for line in ip_data: if line and not line.startswith(&quot;#&quot;): # コメント行をスキップ ip, cidr = line.split('/') subnet = convert_subnet(int(cidr)) output.append(f&quot;{ip}/{subnet}&quot;) file.write(&quot; &quot;.join(output)) # スペースで区切って書き込みprint(&quot;IPリストがjp.allowファイルに変換されました。&quot;) 実行 /etc に書き込むため管理者権限が必要です 1sudo python jp_allow.py 注意 hosts.allowとhosts.denyは接続の度に動的に読み込まれるので、別ターミナル等で試行してからセッションを切断してください","link":"/2025/06/23/jp_allow/"},{"title":"Lambda CI&#x2F;CD アーキテクチャ設計書 - 目次","text":"ドキュメント構成本設計書は、大規模Lambda環境におけるCI/CDアーキテクチャの設計思想と実装指針をまとめたものです。 📑 ドキュメント一覧 1. CI/CD環境構築における方針ファイル: 01_cicd_architecture_principles.md 内容: 設計の背景と課題 アーキテクチャの基本方針 デプロイとリリースの分離戦略 ツール選定の理由（Terraform + SAM + GitHub Actions） スケーラビリティとガバナンスの考慮 2. 具体的な構成要素と役割ファイル: 02_architecture_components.md 内容: システム全体図 リポジトリ構成 各コンポーネントの責任範囲 Terraform（インフラリポジトリ） SAM（アプリケーションリポジトリ） GitHub Actions（CI/CDパイプライン） リソース配置のルール エイリアス管理戦略 3. 各構成要素の実装に関する留意点ファイル: 03_implementation_guidelines.md 内容: Terraform実装ガイドライン IAMロール・ポリシー管理 VPC・ネットワーク設定 SSM Parameter Store活用 SAM実装ガイドライン Lambda関数構成 Layer管理 エイリアス設定 GitHub Actions実装ガイドライン デプロイワークフロー リリースワークフロー 変更検知とパス指定 命名規則とタグ戦略 セキュリティ考慮事項 4. メリットとデメリットとして認識すべきことファイル: 04_tradeoffs_and_considerations.md 内容: アーキテクチャのメリット デメリットと対策 代替アプローチとの比較 移行戦略 運用上の考慮事項 よくある質問（FAQ） 📊 対象読者 アーキテクト: アーキテクチャ全体の理解と意思決定 インフラエンジニア: Terraform実装とインフラ管理 アプリケーションエンジニア: SAMによるLambda開発 DevOpsエンジニア: CI/CDパイプライン構築と運用 🎯 想定環境 規模: 大量のLambda関数（数十〜数百） 組織: 複数チーム（インフラチーム、アプリチーム） 既存環境: Terraform + GitHub Actions 要件: デプロイとリリースの分離 段階的リリース（カナリア、ブルーグリーン） ガバナンス（承認フロー） 高速なイテレーション 📝 読み方 初めて読む方: 順番に1→2→3→4 設計思想を理解したい方: 1→4 実装方法を知りたい方: 2→3 特定のトピックを調べたい方: 各ドキュメントの目次から 🔄 更新履歴 日付 バージョン 変更内容 更新者 2025-XX-XX 1.0.0 初版作成 - 次のドキュメント👉 1. CI/CD環境構築における方針","link":"/2025/11/02/lambda-cicd-00-index/"},{"title":"Lambda CI&#x2F;CD アーキテクチャ - 1. 環境構築における方針","text":"目次 設計の背景と課題 アーキテクチャの基本方針 デプロイとリリースの分離戦略 ツール選定の理由 スケーラビリティとガバナンス 設計の背景と課題 現状の課題認識大規模Lambda環境における典型的な課題： 1. 管理の複雑性課題: 数十〜数百のLambda関数が存在 各関数の依存関係管理が煩雑 Layer管理が属人化 デプロイプロセスが統一されていない 影響: デプロイ時間の増大 本番障害のリスク増加 新規メンバーのオンボーディング困難 2. デプロイとリリースの混同課題: コードのデプロイ = 本番リリース リリースタイミングを制御できない 段階的リリースが困難 ロールバックに時間がかかる 影響: 本番環境への影響リスク 夜間・休日デプロイの増加 ビジネス要件との不整合 3. 組織的な課題課題: インフラチームとアプリチームの責任範囲が曖昧 承認フローが不明確 ガバナンスが効いていない 影響: デプロイの遅延 セキュリティリスク コンプライアンス問題 4. 既存環境の制約状況: 既にTerraformで大部分のインフラを管理 GitHub ActionsでCI/CD構築済み 全てを刷新するのは現実的でない 要件: 既存資産を活用 段階的な移行 チームへの負荷を最小化 アーキテクチャの基本方針1. 関心の分離（Separation of Concerns）原則:異なるライフサイクルを持つものは、異なるツールで管理する 実装: Terraform（インフラ） IAM、VPC、RDS等 変更頻度: 低（月1回以下） 管理者: インフラチーム SAM（アプリケーション） Lambda関数、Layer 変更頻度: 高（週1回以上） 管理者: アプリケーションチーム メリット:✓ デプロイの独立性（互いに影響しない）✓ チーム間の責任範囲が明確✓ 適切なツールで適切な管理 2. デプロイとリリースの分離定義:デプロイ (Deploy): コードをAWSにアップロードする行為 新しいバージョンを作成 本番環境には影響しない リリース (Release): ユーザーに公開する行為 エイリアスを切り替える 本番トラフィックが新バージョンに流れる 重要な原則:デプロイ ≠ リリース 実装: アプリチーム: コードをデプロイ（staging自動） QA: staging環境で検証 インフラチーム: 承認後にproductionリリース 監視: メトリクス確認 問題あれば: 瞬時にロールバック（エイリアス切り替え） 3. Infrastructure as Code の徹底原則:全ての設定をコードで管理し、Gitで追跡可能にする 実装: Terraform: インフラリソース SAM: Lambda関数とその設定 GitHub Actions: CI/CDパイプライン SSM Parameter Store: 環境間の共有値 メリット:✓ 変更履歴の追跡✓ レビュープロセス（Pull Request）✓ 環境の再現性✓ ロールバックの容易性 4. 段階的な環境構成環境構成: Development（開発）: Lambda: $LATEST（常に最新） 用途: 開発者の動作確認 デプロイ: プッシュ時に自動 Staging（検証）: Lambda: 最新バージョン（自動更新） 用途: QA、統合テスト デプロイ: main mergе時に自動 Production（本番）: Lambda: 承認されたバージョン 用途: エンドユーザー向け デプロイ: 手動承認後にリリース 利点:✓ 段階的な検証✓ 本番リスクの最小化✓ ロールバック戦略の明確化 デプロイとリリースの分離戦略なぜ分離が必要かビジネス要件との整合ケース1: タイムセンシティブな機能シナリオ: 新機能を事前にデプロイ キャンペーン開始時刻にリリース（例: 0時） 従来の問題:デプロイ = リリース→ 0時に作業が必要→ 深夜・休日作業 分離後: 事前にデプロイ（営業時間内） 0時にエイリアス切り替え（自動化可能）→ 深夜作業不要 リスク管理ケース2: 段階的リリース要件: まず10%のユーザーでテスト 問題なければ100%に拡大 実装: デプロイ: 新バージョンをアップロード カナリアリリース: 10%トラフィック 監視: エラー率、レイテンシ確認（10分） 問題なし: 100%に切り替え 問題あり: 即座にロールバック メリット:✓ 本番影響の最小化✓ 問題の早期発見✓ 迅速なロールバック 実装メカニズムLambda バージョンとエイリアスコンセプト: Lambda関数├── $LATEST（最新コード）├── Version 14（不変）├── Version 15（不変）└── Version 16（不変）← 最新デプロイ エイリアス（ポインタ）├── development → $LATEST├── staging → Version 16└── production → Version 15 ← 本番はまだ旧版 デプロイ時: コードをアップロード（$LATEST更新） publish-version（Version 16作成） staging エイリアスを更新 production は変更なし ← 影響なし リリース時: production エイリアスを Version 16 に切り替え 本番トラフィックが新バージョンに流れる 数秒で完了 ロールバック時: production エイリアスを Version 15 に戻す 数秒で旧バージョンに復帰 ツール選定の理由Terraform（インフラ管理）選定理由✓ 既存資産 既に大部分のインフラで使用中 チームの習熟度が高い 実績とナレッジの蓄積 ✓ マルチリソース対応 VPC、RDS、S3等を統合管理 Lambdaだけでなく全体を俯瞰 ✓ 状態管理 terraform.tfstate で現状を把握 plan で変更影響を事前確認 ✓ モジュール化 再利用可能な構成 組織標準の確立 Lambdaには使わない理由✗ Lambda専用に最適化されていない ビルドプロセスが煩雑 Layer管理が面倒 ローカルテストが困難 ✗ デプロイが遅い plan/apply のオーバーヘッド 全リソースのチェック Lambda更新に数分以上 ✗ 開発者体験 アプリ開発者にTerraformを強制 学習コストが高い イテレーション速度が低下 SAM（Lambda管理）選定理由✓ Lambda専用に最適化 sam build で自動ビルド Layer管理が簡単 依存関係の自動解決 ✓ 開発者体験 sam local で局所テスト シンプルなYAML設定 高速なデプロイ（1-2分） ✓ AWS公式サポート CloudFormationベース AWSベストプラクティス 継続的な機能追加 ✓ エイリアス管理 AutoPublishAlias機能 デプロイメントプリファレンス カナリアデプロイ標準装備 他ツールとの比較vs Serverless Framework:SAMを選んだ理由: AWS公式（長期サポート保証） CloudFormationとの親和性 学習コストが低い AWS統合（X-Ray、CloudWatch等） vs Terraform（Lambda管理）:SAMを選んだ理由: Lambda特化の機能 デプロイ速度（10倍以上高速） 開発者体験 ローカルテスト環境 GitHub Actions（CI/CD）選定理由✓ 既存資産 既にCI/CDで使用中 GitHub Enterprise利用 ✓ GitHubネイティブ Pull Request連動 レビューフロー統合 Secretsストア ✓ 柔軟性 ワークフローをコードで管理 複雑なロジックも実装可能 再利用可能なアクション ✓ コスト GitHub Enterprise契約内 追加コスト不要 スケーラビリティとガバナンススケーラビリティへの対応関数数の増加課題: 100個以上のLambda関数 対策: 関数のグルーピング├── auth-functions├── data-functions├── api-functions└── batch-functions 並列デプロイ 各グループを並列実行 デプロイ時間の短縮 選択的デプロイ 変更検知（git diff） 影響範囲のみデプロイ チーム数の増加課題: 複数チームでのLambda開発 対策: リポジトリ分離team-a-lambdas/team-b-lambdas/team-c-lambdas/ 共通基盤の提供 共通Layer（Terraformで管理） デプロイテンプレート ベストプラクティス 独立したデプロイ チーム間の依存を最小化 並行開発を可能に ガバナンスの確保承認フローステージごとの承認レベル: Development: 承認: 不要 デプロイ: 自動（プッシュ時） リスク: 低 Staging: 承認: Pull Request承認 デプロイ: 自動（merge時） リスク: 低 Production: 承認: 必須 Pull Request承認（コードレビュー） リリース申請（Slack等） インフラチーム承認 リリース実行 デプロイ: 手動トリガー リスク: 高 監査証跡記録する情報: Git commit（コード変更） GitHub Actions実行ログ Lambda バージョン発行履歴 エイリアス切り替え履歴 SSM Parameter Store変更履歴 CloudWatch Logs 用途: 問題発生時の原因調査 コンプライアンス対応 セキュリティ監査 セキュリティ管理原則: 最小権限の原則 ロールベースアクセス制御 シークレット管理の徹底 実装: IAMロール（Terraformで管理） インフラチームがレビュー 承認プロセス必須 GitHub Secrets AWS認証情報 API Key等 Secrets Manager / SSM Parameter Store 実行時のシークレット 暗号化必須 OIDCによる認証 長期認証情報の排除 動的な権限付与 方針のまとめ核心的な原則 関心の分離 Terraform: インフラ（低頻度変更） SAM: Lambda（高頻度変更） デプロイとリリースの分離 デプロイ: 自由に、頻繁に リリース: 慎重に、承認後に Infrastructure as Code 全てをコードで管理 Gitで追跡可能 段階的な検証 development → staging → production 各環境で確認 適切なツール選択 既存資産の活用 Lambda特化ツール（SAM）の導入 達成される価値開発チーム:✓ 高速なイテレーション✓ ローカルテスト環境✓ シンプルな設定 インフラチーム:✓ ガバナンスの確保✓ リリース制御✓ セキュリティ管理 ビジネス:✓ リリースタイミングの制御✓ リスクの最小化✓ 迅速なロールバック 組織全体:✓ 明確な責任範囲✓ スケーラビリティ✓ 監査証跡の確保 次のステップこの方針を具体的なアーキテクチャに落とし込みます。 👉 次へ: 2. 具体的な構成要素と役割","link":"/2025/11/02/lambda-cicd-01-principles/"},{"title":"Lambda CI&#x2F;CD アーキテクチャ - 2. 構成要素と役割","text":"目次 システム全体図 リポジトリ構成 各コンポーネントの責任範囲 リソース配置のルール エイリアス管理戦略 連携メカニズム システム全体図 アーキテクチャ概要 データフロー リポジトリ構成terraform-infrastructure（インフラリポジトリ）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960terraform-infrastructure/├── README.md├── .github/│ └── workflows/│ ├── terraform-plan.yml # PR時のplan│ ├── terraform-apply.yml # merge時のapply│ └── lambda-release.yml # 本番リリース│├── environments/ # 環境別設定│ ├── production/│ │ ├── backend.tf│ │ ├── terraform.tfvars│ │ └── main.tf│ ├── staging/│ └── development/│├── modules/ # 再利用可能モジュール│ ├── vpc/│ │ ├── main.tf│ │ ├── variables.tf│ │ └── outputs.tf│ ├── rds/│ ├── lambda-role/│ └── shared-bucket/│├── iam/ # IAM管理│ ├── lambda-roles.tf # Lambda実行ロール│ ├── lambda-policies.tf # ポリシー│ └── outputs.tf│├── vpc/ # ネットワーク│ ├── main.tf│ ├── subnets.tf│ ├── security-groups.tf│ └── outputs.tf│├── data-stores/ # データストア│ ├── rds.tf│ ├── dynamodb.tf│ ├── s3.tf│ └── outputs.tf│├── messaging/ # メッセージング│ ├── sqs.tf│ ├── sns.tf│ ├── eventbridge-pipes.tf│ └── outputs.tf│├── shared-values/ # 共有値管理│ ├── main.tf # SSM Parameter出力│ └── outputs.tf│├── lambda-aliases/ # エイリアス定義│ ├── aliases.tf # エイリアスリソース│ └── variables.tf│└── scripts/ # 運用スクリプト ├── release-lambda.sh # リリーススクリプト ├── rollback-lambda.sh # ロールバック └── canary-release.sh # カナリアリリース lambda-applications（アプリケーションリポジトリ）12345678910111213141516171819202122232425262728293031323334353637383940414243444546lambda-applications/├── README.md├── .github/│ └── workflows/│ ├── deploy-staging.yml # staging自動デプロイ│ ├── deploy-production.yml # production申請│ └── run-tests.yml # テスト実行│├── template.yaml # SAMメインテンプレート├── samconfig.toml # SAM設定│├── functions/ # Lambda関数│ ├── auth/│ │ ├── login/│ │ │ ├── app.py│ │ │ ├── requirements.txt│ │ │ └── tests/│ │ ├── logout/│ │ └── refresh-token/│ ││ ├── orders/│ │ ├── create-order/│ │ ├── update-order/│ │ └── cancel-order/│ ││ ├── payments/│ └── notifications/│├── layers/ # Lambda Layer│ ├── dependencies/│ │ ├── python/│ │ └── requirements.txt│ └── company-utils/│ └── python/│ └── company/│ ├── logger.py│ ├── auth.py│ └── database.py│├── tests/ # 統合テスト│ ├── integration/│ └── e2e/│└── docs/ # ドキュメント ├── architecture.md └── deployment.md 各コンポーネントの責任範囲Terraform（インフラリポジトリ）管理対象責任範囲: インフラストラクチャ全般: - VPC、サブネット、セキュリティグループ - RDS、DynamoDB、ElastiCache - S3バケット（共有） - IAMロール、ポリシー - Secrets Manager、SSM Parameter Store - EventBridge Pipes - SQS/SNS（共有） - API Gateway（複雑な構成の場合） Lambda関連（限定的）: - Lambda実行ロール - エイリアス定義（枠組み） - 認証Lambda（API Gateway Authorizer等） - 監視Lambda（ログ集約、セキュリティ監視） 管理しないもの: Lambda関数コード Lambda Layer（ビジネスロジック） Lambda専用リソース（頻繁に変更） 出力値（SSM Parameter Store）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# terraform-infrastructure/shared-values/main.tf# IAMresource &quot;aws_ssm_parameter&quot; &quot;lambda_execution_role_arn&quot; { name = &quot;/shared/iam/lambda-execution-role-arn&quot; type = &quot;String&quot; value = aws_iam_role.lambda_execution.arn}# VPCresource &quot;aws_ssm_parameter&quot; &quot;vpc_subnet_ids&quot; { name = &quot;/shared/vpc/private-subnet-ids&quot; type = &quot;StringList&quot; value = join(&quot;,&quot;, aws_subnet.private[*].id)}resource &quot;aws_ssm_parameter&quot; &quot;vpc_security_group_id&quot; { name = &quot;/shared/vpc/lambda-security-group-id&quot; type = &quot;String&quot; value = aws_security_group.lambda.id}# データストアresource &quot;aws_ssm_parameter&quot; &quot;rds_endpoint&quot; { name = &quot;/shared/rds/endpoint&quot; type = &quot;String&quot; value = aws_db_instance.main.endpoint}resource &quot;aws_ssm_parameter&quot; &quot;dynamodb_table_name&quot; { name = &quot;/shared/dynamodb/orders-table-name&quot; type = &quot;String&quot; value = aws_dynamodb_table.orders.name}# S3resource &quot;aws_ssm_parameter&quot; &quot;data_bucket_name&quot; { name = &quot;/shared/s3/data-bucket-name&quot; type = &quot;String&quot; value = aws_s3_bucket.data.id}# メッセージングresource &quot;aws_ssm_parameter&quot; &quot;notification_topic_arn&quot; { name = &quot;/shared/sns/notification-topic-arn&quot; type = &quot;String&quot; value = aws_sns_topic.notifications.arn} SAM（アプリケーションリポジトリ）管理対象責任範囲: Lambda関数: - ビジネスロジック実装 - 関数設定（メモリ、タイムアウト等） - 環境変数 - トリガー設定 Lambda Layer: - 依存関係Layer（pip、npm等） - 共通ユーティリティLayer - Layerのビルドとデプロイ Lambda専用リソース: - 専用SQSキュー（頻繁に調整） - 専用EventBridgeルール - 専用DynamoDBテーブル（小規模） エイリアス: - stagingエイリアス（自動更新） - productionエイリアス（定義のみ） 管理しないもの: インフラストラクチャ（VPC、RDS等） IAMロール（実行ロール） 共有リソース SAMテンプレート構造123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990# lambda-applications/template.yamlAWSTemplateFormatVersion: '2010-09-09'Transform: AWS::Serverless-2016-10-31Parameters: # Terraformから取得する値 LambdaExecutionRoleArn: Type: AWS::SSM::Parameter::Value&lt;String&gt; Default: /shared/iam/lambda-execution-role-arn VpcSubnetIds: Type: AWS::SSM::Parameter::Value&lt;List&lt;String&gt;&gt; Default: /shared/vpc/private-subnet-ids VpcSecurityGroupId: Type: AWS::SSM::Parameter::Value&lt;String&gt; Default: /shared/vpc/lambda-security-group-id DataBucketName: Type: AWS::SSM::Parameter::Value&lt;String&gt; Default: /shared/s3/data-bucket-nameGlobals: Function: Runtime: python3.11 Timeout: 30 MemorySize: 512 Role: !Ref LambdaExecutionRoleArn VpcConfig: SubnetIds: !Ref VpcSubnetIds SecurityGroupIds: - !Ref VpcSecurityGroupIdResources: # Layer定義 DependenciesLayer: Type: AWS::Serverless::LayerVersion Properties: LayerName: common-dependencies ContentUri: layers/dependencies/ CompatibleRuntimes: - python3.11 Metadata: BuildMethod: python3.11 CompanyUtilsLayer: Type: AWS::Serverless::LayerVersion Properties: LayerName: company-utils ContentUri: layers/company-utils/ CompatibleRuntimes: - python3.11 # Lambda関数 UserLoginFunction: Type: AWS::Serverless::Function Properties: FunctionName: user-login-function CodeUri: functions/auth/login/ Handler: app.handler Layers: - !Ref DependenciesLayer - !Ref CompanyUtilsLayer Environment: Variables: DATA_BUCKET: !Ref DataBucketName LOG_LEVEL: INFO # stagingエイリアス（自動更新） UserLoginStagingAlias: Type: AWS::Lambda::Alias Properties: FunctionName: !Ref UserLoginFunction FunctionVersion: !GetAtt UserLoginFunctionVersion.Version Name: staging UserLoginFunctionVersion: Type: AWS::Lambda::Version Properties: FunctionName: !Ref UserLoginFunction # productionエイリアス（定義のみ、更新は手動） UserLoginProductionAlias: Type: AWS::Lambda::Alias Properties: FunctionName: !Ref UserLoginFunction FunctionVersion: &quot;1&quot; # 初期値 Name: production DeletionPolicy: Retain GitHub Actions（CI/CDパイプライン）Terraformワークフロー123456789101112131415161718192021222324252627282930313233# terraform-infrastructure/.github/workflows/terraform-apply.ymlname: Terraform Applyon: push: branches: [main] paths: - 'terraform/**' - 'environments/**' - 'modules/**'jobs: terraform: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - uses: hashicorp/setup-terraform@v3 - uses: aws-actions/configure-aws-credentials@v4 with: role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE }} aws-region: ap-northeast-1 - name: Terraform Init run: terraform init - name: Terraform Plan run: terraform plan -out=tfplan - name: Terraform Apply run: terraform apply tfplan SAMワークフロー123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# lambda-applications/.github/workflows/deploy-staging.ymlname: Deploy to Stagingon: push: branches: [main] paths: - 'functions/**' - 'layers/**' - 'template.yaml'jobs: deploy: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - uses: aws-actions/setup-sam@v2 - uses: aws-actions/configure-aws-credentials@v4 with: role-to-assume: ${{ secrets.AWS_LAMBDA_ROLE }} aws-region: ap-northeast-1 - name: SAM Build run: sam build --use-container - name: SAM Deploy run: sam deploy --no-confirm-changeset --no-fail-on-empty-changeset - name: Publish Version id: version run: | VERSION=$(aws lambda publish-version \\ --function-name user-login-function \\ --description &quot;Commit: ${{ github.sha }}&quot; \\ --query 'Version' \\ --output text) echo &quot;version=$VERSION&quot; &gt;&gt; $GITHUB_OUTPUT - name: Save Version to SSM run: | aws ssm put-parameter \\ --name &quot;/apps/user-login-function/latest-version&quot; \\ --value &quot;${{ steps.version.outputs.version }}&quot; \\ --type String \\ --overwrite リソース配置のルール判断フローチャートリソースの配置を決める: Q1: ライフサイクルは？├─ 頻繁に変更（週1回以上） → Q2へ└─ 稀（月1回以下） → Terraform Q2: 共有度は？├─ 複数サービスで使用 → Terraform└─ Lambda専用 → SAM Q3: リソースの性質は？├─ セキュリティ/認証 → Terraform├─ 監視/ログ基盤 → Terraform└─ ビジネスロジック → SAM リソース配置マトリックス リソース 配置 理由 IAMロール Terraform セキュリティ、共有 VPC/Subnet/SG Terraform インフラ基盤 RDS/DynamoDB(共有) Terraform 複数サービスで使用 S3(共有) Terraform 複数サービスで使用 Secrets Manager Terraform セキュリティ EventBridge Pipes Terraform 共有、監視重要 SQS/SNS(共有) Terraform 複数サービスで使用 Lambda関数 SAM 頻繁に変更 Lambda Layer SAM 頻繁に変更 SQS/SNS(専用) SAM 関数と密結合 EventBridge(専用) SAM 関数と密結合 DynamoDB(専用小規模) SAM 関数専用 具体例ケース1: SQS123456789101112# 共有キュー（複数サービスが使用） → Terraformresource &quot;aws_sqs_queue&quot; &quot;order_processing&quot; { name = &quot;order-processing-queue&quot; # Lambda、API、バッチ処理が使用}# 専用キュー（特定関数のみ、設定を頻繁に調整） → SAMResources: ImageProcessingQueue: Type: AWS::SQS::Queue Properties: VisibilityTimeout: 300 # 頻繁に調整 ケース2: EventBridge1234567891011121314# EventBridge Pipes（複数サービス接続） → Terraformresource &quot;aws_pipes_pipe&quot; &quot;stream_processor&quot; { source = aws_dynamodb_table.orders.stream_arn target = aws_sqs_queue.processing.arn}# EventBridge Rule（特定関数専用） → SAMResources: DailyReportSchedule: Type: AWS::Events::Rule Properties: ScheduleExpression: cron(0 9 * * ? *) Targets: - Arn: !GetAtt ReportFunction.Arn ケース3: Lambda関数の分類1234567891011# インフラ系Lambda（認証、監視） → Terraformresource &quot;aws_lambda_function&quot; &quot;api_authorizer&quot; { function_name = &quot;api-gateway-authorizer&quot; # 全APIで使用、セキュリティ重要}# ビジネスロジックLambda → SAMResources: OrderProcessingFunction: Type: AWS::Serverless::Function # ビジネスロジック、頻繁に変更 エイリアス管理戦略エイリアスの役割エイリアス = Lambda関数バージョンへのポインタ 目的: デプロイとリリースの分離 環境の識別（development、staging、production） トラフィック制御（カナリア、ブルーグリーン） 瞬時のロールバック エイリアス構成123456789101112131415Lambda関数: user-login-function│├── Versions（不変）│ ├── $LATEST（最新コード）│ ├── Version 1│ ├── Version 2│ ├── ...│ ├── Version 14│ ├── Version 15（現在の本番）│ └── Version 16（新バージョン）│└── Aliases（ポインタ） ├── development → $LATEST ├── staging → Version 16 └── production → Version 15 環境別のエイリアス戦略Development目的: 開発者の動作確認 設定: エイリアス: development バージョン: $LATEST（常に最新） 更新: 自動（デプロイ時） 特徴: 最新コードを即座に反映 不安定でも問題ない デバッグ環境 Staging目的: QA、統合テスト 設定: エイリアス: staging バージョン: 最新発行バージョン 更新: 自動（CI/CD） フロー: mainブランチにmerge SAM build &amp; deploy Versionを発行 stagingエイリアスを自動更新 特徴: 本番リリース前の最終確認 安定したバージョン 本番環境に近い設定 Production目的: エンドユーザー向け 設定: エイリアス: production バージョン: 承認されたバージョン 更新: 手動（承認後） フロー: staging で検証完了 リリース申請（Slack等） インフラチーム承認 リリースワークフロー実行 productionエイリアスを更新 特徴: 最も慎重な管理 承認プロセス必須 ロールバック準備 エイリアス更新の実装SAM側（staging自動更新）12345678910111213141516171819202122232425262728# template.yamlResources: UserLoginFunction: Type: AWS::Serverless::Function # ... # stagingは自動更新 StagingAlias: Type: AWS::Lambda::Alias Properties: FunctionName: !Ref UserLoginFunction FunctionVersion: !GetAtt LatestVersion.Version Name: staging LatestVersion: Type: AWS::Lambda::Version Properties: FunctionName: !Ref UserLoginFunction Description: !Sub &quot;Deployed: ${AWS::StackName}&quot; # productionは定義のみ ProductionAlias: Type: AWS::Lambda::Alias Properties: FunctionName: !Ref UserLoginFunction FunctionVersion: &quot;1&quot; # 初期値 Name: production DeletionPolicy: Retain 手動リリース（production更新）12345678910111213141516171819202122232425262728293031323334353637383940# .github/workflows/release-production.ymlname: Release to Productionon: workflow_dispatch: inputs: function_name: description: 'Function name' required: true version: description: 'Version to release' required: truejobs: release: runs-on: ubuntu-latest steps: - name: Update Production Alias run: | aws lambda update-alias \\ --function-name ${{ inputs.function_name }} \\ --name production \\ --function-version ${{ inputs.version }} - name: Verify run: | # エイリアスが正しく更新されたか確認 CURRENT_VERSION=$(aws lambda get-alias \\ --function-name ${{ inputs.function_name }} \\ --name production \\ --query 'FunctionVersion' \\ --output text) if [ &quot;$CURRENT_VERSION&quot; == &quot;${{ inputs.version }}&quot; ]; then echo &quot;✅ Successfully released version ${{ inputs.version }}&quot; else echo &quot;❌ Release failed&quot; exit 1 fi 連携メカニズムSSM Parameter Store による連携フロー: Terraformがリソース作成└─ IAMロール、VPC、RDS等 TerraformがSSMに値を出力└─ /shared/* パラメータ SAMがSSMから値を取得└─ Parameters セクションで参照 Lambda関数が設定される└─ 正しいロール、VPC、接続情報 具体例Terraform側1234567891011121314151617# IAMロール作成resource &quot;aws_iam_role&quot; &quot;lambda_execution&quot; { name = &quot;lambda-execution-role&quot; # ...}# SSMに出力resource &quot;aws_ssm_parameter&quot; &quot;lambda_role_arn&quot; { name = &quot;/shared/iam/lambda-execution-role-arn&quot; type = &quot;String&quot; value = aws_iam_role.lambda_execution.arn tags = { ManagedBy = &quot;Terraform&quot; Description = &quot;Lambda execution role ARN for SAM&quot; }} SAM側123456789101112# SSMから取得Parameters: LambdaRoleArn: Type: AWS::SSM::Parameter::Value&lt;String&gt; Default: /shared/iam/lambda-execution-role-arn# Lambda関数で使用Resources: MyFunction: Type: AWS::Serverless::Function Properties: Role: !Ref LambdaRoleArn # SSMから取得した値 バージョン情報の共有フロー: SAMがLambdaをデプロイ バージョンを発行 バージョン情報をSSMに保存└─ /apps/{function-name}/latest-version インフラチームが参照 承認後、リリーススクリプトで使用 実装123456789101112131415161718192021# SAM デプロイ後- name: Save Version Info run: | VERSION=${{ steps.version.outputs.version }} # バージョン番号 aws ssm put-parameter \\ --name &quot;/apps/${{ inputs.function_name }}/latest-version&quot; \\ --value &quot;$VERSION&quot; \\ --overwrite # メタデータ aws ssm put-parameter \\ --name &quot;/apps/${{ inputs.function_name }}/version-$VERSION/metadata&quot; \\ --value '{ &quot;version&quot;: &quot;'$VERSION'&quot;, &quot;commit&quot;: &quot;${{ github.sha }}&quot;, &quot;deployed_at&quot;: &quot;'$(date -u +%Y-%m-%dT%H:%M:%SZ)'&quot;, &quot;deployed_by&quot;: &quot;${{ github.actor }}&quot; }' \\ --overwrite まとめ構成要素の役割Terraform:✓ インフラストラクチャ✓ IAM、VPC、データストア✓ 共有リソース✓ 安定した設定 SAM:✓ Lambda関数とLayer✓ ビジネスロジック✓ 頻繁に変更するもの✓ Lambda専用リソース GitHub Actions:✓ CI/CDパイプライン✓ 自動化ワークフロー✓ 承認フロー SSM Parameter Store:✓ 設定値の共有✓ バージョン情報の保存✓ Terraform ↔ SAM 連携 連携の要点 SSM Parameter Storeが橋渡し stagingは自動、productionは手動 バージョン情報を共有 明確な責任範囲 次のステップ構成要素を理解したら、実装の詳細に進みます。 👉 次へ: 3. 各構成要素の実装に関する留意点","link":"/2025/11/02/lambda-cicd-02-components/"},{"title":"Lambda CI&#x2F;CD アーキテクチャ - 4. メリット・デメリット","text":"目次 アーキテクチャのメリット デメリットと対策 代替アプローチとの比較 移行戦略 運用上の考慮事項 よくある質問（FAQ） アーキテクチャのメリット 1. デプロイとリリースの分離メリット状況:従来 → デプロイ = リリース（本番への影響が即座に発生）改善 → デプロイ ≠ リリース（影響を制御可能） 具体的な効果:✓ 営業時間内にデプロイ、指定時刻にリリース可能✓ 段階的リリース（カナリア、ブルーグリーン）✓ ビジネス要件に合わせたタイミング制御✓ 瞬時のロールバック（秒単位） 実例シナリオ1: キャンペーン開始に合わせた新機能リリース 従来: 0時にデプロイ作業（深夜作業必須） デプロイに5-10分 問題発生時の対応が困難 改善後: 前日17時にデプロイ（営業時間内） staging環境で最終確認 0時にエイリアス切り替え（自動化） 問題発生時は即座にロールバック（数秒） 結果:✓ 深夜作業の削減✓ リスクの最小化✓ チームの負担軽減 シナリオ2: 重要な機能の段階的リリース 要件: まず10%のユーザーでテスト 問題なければ徐々に拡大 実装: 新バージョンをデプロイ production エイリアスで10%トラフィック 10分間監視（エラー率、レイテンシ） 問題なし → 50% → 100% 問題あり → 即座にロールバック 結果:✓ 全ユーザーへの影響を回避✓ 問題の早期発見✓ ビジネスリスクの最小化 2. 明確な責任範囲メリットチーム構成: インフラチーム:✓ 基盤の安定性に集中✓ セキュリティ管理✓ コスト最適化✓ ガバナンス アプリケーションチーム:✓ 機能開発に集中✓ 高速なイテレーション✓ ビジネス価値の提供✓ 品質向上 衝突の回避:✓ 互いのデプロイが独立✓ 変更の影響範囲が明確✓ レビュープロセスの最適化 効果測定Before（Terraform一本化）: Lambda変更 → Terraform plan/apply（10-15分） インフラチームのレビュー必須 デプロイ待ち時間が長い デプロイ頻度: 週1-2回 After（Terraform + SAM分離）: Lambda変更 → SAM deploy（1-2分） アプリチームで完結 待ち時間最小 デプロイ頻度: 日次複数回 改善:✓ デプロイ時間: 87%短縮✓ デプロイ頻度: 10倍向上✓ チーム間の依存: 90%削減 3. 高速なイテレーションメリット開発サイクルの比較: 従来（Terraformのみ）: コード変更 ビルド（手動） Terraform plan（全体） レビュー待ち Terraform apply デプロイ完了合計: 20-30分 改善後（SAM）: コード変更 sam build（自動） sam deploy デプロイ完了合計: 2-3分 効果:✓ フィードバックループの高速化✓ 試行錯誤が容易✓ 生産性の向上 ローカル開発環境12345678910111213# SAMの強力な機能# ローカルでLambda実行$ sam local invoke UserLoginFunction \\ --event events/login-event.json# ローカルでAPI Gateway起動$ sam local start-api# → http://localhost:3000 でテスト可能# ローカルでLayerテスト$ sam local invoke \\ --layer-cache-basedir ./layer-cache メリット:✓ AWSへのデプロイ不要✓ 高速な動作確認✓ デバッグが容易✓ 開発コストの削減 4. Layer管理の自動化メリットBefore（Terraformのみ）: 依存関係を手動インストール$ pip install -r requirements.txt -t python/ 手動でzip作成$ zip -r layer.zip python/ Terraformで管理source_code_hash = filebase64sha256(“layer.zip”) 変更検知が不完全 デプロイが遅い After（SAM）: requirements.txt を更新 sam build→ 自動的にビルド→ 自動的にLayer作成→ 依存関係解決 sam deploy→ 自動的にアップロード→ 自動的にバージョン管理 効果:✓ 作業時間: 80%削減✓ ミスの防止✓ 一貫性の確保 具体例123456789101112131415161718192021222324# SAMテンプレート（シンプル）Resources: DependenciesLayer: Type: AWS::Serverless::LayerVersion Properties: ContentUri: layers/dependencies/ CompatibleRuntimes: - python3.11 Metadata: BuildMethod: python3.11 # これだけで自動ビルド# 複数関数で共有 Function1: Type: AWS::Serverless::Function Properties: Layers: - !Ref DependenciesLayer Function2: Type: AWS::Serverless::Function Properties: Layers: - !Ref DependenciesLayer メリット:✓ Layer更新時、全関数に自動反映✓ バージョン管理が自動✓ 設定ミスの防止 5. ガバナンスの確保メリット承認フロー: Staging（自動）: Pull Request承認 自動デプロイ QA確認 Production（手動承認）: リリース申請 インフラチーム承認 メトリクス確認 承認後リリース 効果:✓ 変更の可視化✓ リスク管理✓ コンプライアンス対応✓ 監査証跡の確保 監査証跡記録される情報: コード変更: Git commit履歴 Pull Request レビューコメント 承認者 デプロイ履歴: GitHub Actions実行ログ デプロイ日時 実行者 成功/失敗 バージョン情報: Lambda Version番号 SSM Parameter Store メタデータ（commit、日時、実行者） リリース履歴: エイリアス切り替え履歴 CloudTrail 承認者 ロールバック履歴 用途:✓ 障害調査✓ セキュリティ監査✓ コンプライアンス報告 デメリットと対策1. 複雑性の増加デメリット問題: 2つのリポジトリ管理 2つのツール（Terraform、SAM）習得 連携メカニズムの理解必要 新規メンバーのオンボーディング時間増加 影響: 学習コスト ドキュメント整備の必要性 トラブルシューティングの難易度上昇 対策対策1: ドキュメント整備実施: アーキテクチャ設計書（本ドキュメント） 運用手順書 トラブルシューティングガイド FAQ 対策2: テンプレート・サンプル提供実施: 新規Lambda関数のテンプレート よくあるパターンのサンプル GitHub Actionsのテンプレート 対策3: オンボーディングプログラム実施: 新規メンバー向けトレーニング ペアプログラミング メンター制度 対策4: ツールの標準化実施: CLIツール（sam, terraform） VS Code拡張機能 プリコミットフック 2. リリース待ち時間デメリット問題:stagingデプロイ後、production承認待ち フロー: コミット staging自動デプロイ（2分） QA確認（30分-数時間） リリース申請 インフラチーム承認待ち（状況により数時間） production リリース 懸念: 緊急時の対応遅延 ビジネス機会の損失 対策対策1: 承認プロセスの最適化実施: 緊急リリース用の特別フロー オンコール体制 Slack通知 + ワンクリック承認 営業時間外の対応ルール明確化 対策2: 自動承認の条件定義実施: 低リスク変更は自動承認例: ログレベル変更、タイムアウト調整 重要度による分類 Critical: 手動承認必須 High: インフラチーム承認 Medium: リードエンジニア承認 Low: 自動承認 対策3: ホットフィックスフロー実施:緊急時（本番障害等）: ホットフィックスブランチ作成 最小限の修正 即座にproduction直接デプロイ 事後レビュー 対策4: 時間帯によるフロー変更実施:営業時間内: 通常の承認フロー営業時間外・休日: 自動承認（監視強化） 翌営業日に事後レビュー 3. 管理コストデメリット問題: 2つのリポジトリの管理 CI/CDパイプラインの維持 SSM Parameter Storeの管理 依存関係の同期 コスト: インフラチームの作業時間増加 メンテナンス工数 対策対策1: 自動化の徹底実施: Renovate/Dependabotで依存関係自動更新 Terraformのモジュール化 SAMテンプレートの再利用 GitHub Actionsの共通化 対策2: モニタリング・アラート実施: デプロイ失敗の自動検知 Slackへの自動通知 ダッシュボードの整備 異常検知の自動化 対策3: ツール統合実施: terraform-docsで自動ドキュメント生成 SAM CLIのCI/CD統合 共通スクリプトの整備 4. エイリアス管理の手動操作デメリット問題:production エイリアスの手動切り替え リスク: 人的ミス（間違ったバージョン指定） 手順の抜け漏れ ロールバック手順の失敗 対策対策1: スクリプト化・自動化実施: リリーススクリプトの整備 ロールバックスクリプトの整備 バージョン検証の自動化 チェックリストの自動化 対策2: GitHub Actionsワークフロー実施: workflow_dispatch（手動トリガー） バージョン選択のドロップダウン 自動検証 ロールバック機能 対策3: 多段階確認実施: バージョン存在確認 メタデータ表示 承認（GitHub Environment） リリース実行 検証 通知 対策4: ドライラン機能実施: 実行前に影響確認 変更内容の表示 –dry-run オプション 代替アプローチとの比較アプローチ1: Terraform完全管理構成: 全てTerraformで管理 Lambda関数もTerraform エイリアスもTerraform メリット:✓ ツールが1つ（学習コスト低）✓ 状態管理が統一✓ 一貫性 デメリット:✗ Lambda開発体験が悪い✗ デプロイが遅い（10-15分）✗ ローカルテストが困難✗ Layer管理が煩雑✗ ビルドプロセスが複雑 評価:小規模（Lambda 10個未満）: ⭐⭐⭐中規模（10-50個）: ⭐⭐大規模（50個以上）: ⭐ 非推奨 アプローチ2: SAM完全管理構成: 全てSAMで管理 インフラもSAM（CloudFormation） エイリアスもSAM メリット:✓ ツールが1つ✓ Lambda最適化✓ デプロイが高速✓ 開発体験が良い デメリット:✗ 既存Terraform資産を活用できない✗ CloudFormationの制約✗ 複雑なインフラ管理が困難✗ 組織標準と異なる可能性 評価:既存Terraform資産なし: ⭐⭐⭐⭐既存Terraform資産あり: ⭐⭐大規模インフラ: ⭐ アプローチ3: Serverless Framework構成: Serverless Frameworkで管理 プラグインで拡張 メリット:✓ Lambda特化✓ 豊富なプラグイン✓ コミュニティが大きい✓ マルチクラウド対応 デメリット:✗ 既存Terraform資産を活用できない✗ 組織標準と異なる✗ AWS外の学習も必要✗ 不変性の管理が弱い 評価:新規プロジェクト: ⭐⭐⭐既存Terraform環境: ⭐⭐ アプローチ4: Terraform + SAM（推奨）構成: インフラ: Terraform Lambda: SAM 連携: SSM Parameter Store メリット:✓ 既存資産活用✓ 適材適所のツール選択✓ 責任範囲が明確✓ Lambda開発体験が良い✓ 高速なイテレーション デメリット:✗ 複雑性の増加✗ 学習コストが高い✗ 管理コスト 評価:小規模: ⭐⭐⭐中規模: ⭐⭐⭐⭐⭐ 推奨大規模: ⭐⭐⭐⭐⭐ 推奨既存Terraform環境: ⭐⭐⭐⭐⭐ 最適 移行戦略フェーズ1: 準備（1-2週間）目標: 環境準備 チーム教育 パイロットプロジェクト選定 タスク: ドキュメント整備: アーキテクチャ設計書 移行計画書 運用手順書 環境構築: リポジトリ作成 CI/CDパイプライン基盤 SSM Parameter Store設計 チーム教育: SAM基礎トレーニング ハンズオン Q&amp;Aセッション パイロット選定: 低リスクなLambda関数選定 3-5個程度 頻繁に変更されるもの優先 フェーズ2: パイロット実施（2-4週間）目標: 小規模で実証 問題点の洗い出し プロセスの改善 手順: Terraform側準備: SSM Parameter Store出力 IAMロール整備 SAM側実装: 選定した関数をSAM化 Layerの移行 エイリアス設定 CI/CD構築: GitHub Actionsワークフロー staging自動デプロイ production手動リリース 検証: デプロイ時間測定 問題点の記録 フィードバック収集 改善: ドキュメント更新 プロセス改善 ツール改善 フェーズ3: 段階的展開（2-3ヶ月）目標: 全Lambda関数の移行 チーム全体への展開 優先順位: 高頻度変更の関数 毎週変更されるもの ビジネスロジック中心 Layer管理が必要な関数 依存関係が多い 共通コード使用 その他の関数 低頻度変更 シンプルな関数 ペース: Week 1-2: 10関数 Week 3-4: 20関数 Week 5-6: 30関数 … 注意点: 無理に全て移行しない 問題が出たら立ち止まる フィードバックを反映 フェーズ4: 安定化（1ヶ月）目標: 運用の定着 ドキュメント完成 KPI確認 タスク: 運用監視: デプロイ頻度 デプロイ時間 失敗率 ロールバック回数 チームフィードバック: 開発者満足度 問題点収集 改善要望 ドキュメント完成: トラブルシューティング ベストプラクティス FAQ KPI評価:Before vs After: デプロイ時間 デプロイ頻度 生産性 障害対応時間 運用上の考慮事項日常運用週次作業: デプロイ状況レビュー エラー率確認 コスト確認 月次作業: Lambda関数のレビュー Layer使用状況確認 不要なバージョン削除 IAMロール・ポリシーレビュー 四半期作業: アーキテクチャレビュー セキュリティ監査 コスト最適化 ドキュメント更新 トラブルシューティングよくある問題と対処: 問題1: SAMデプロイ失敗原因: IAM権限不足 SSMパラメータが存在しない ビルド失敗 対処: CloudFormationスタックのイベント確認 エラーメッセージから原因特定 ロールバック（sam deploy –no-execute-changeset） 問題2: エイリアス切り替え失敗原因: バージョンが存在しない 権限不足 対処: バージョン存在確認 エイリアス現在値確認 手動でAWS CLIから切り替え 問題3: Layer読み込み失敗原因: Layerのディレクトリ構造が間違い CompatibleRuntimesが一致しない 対処: Layerの構造確認（/opt/python/） ランタイムバージョン確認 ローカルでテスト（sam local） コスト管理コスト要因: Lambda実行: リクエスト数 実行時間 メモリサイズ 最適化: 不要なログ削減 メモリサイズの適正化 実行時間の最適化 Provisioned Concurrency（必要時のみ） NAT Gateway: AZごとに$0.045/hour データ転送費 最適化: VPC Endpoint活用 開発環境はNAT不要 S3（アーティファクト保存）: ストレージ費用 リクエスト費用 最適化: ライフサイクルポリシー 古いバージョン削除 よくある質問（FAQ）Q1: なぜTerraformとSAMの両方を使うのか？A: 適材適所のツール選択です。 理由: Terraform: インフラ全般の管理に優れる既存資産があり、チームが習熟している SAM: Lambda専用に最適化されている開発体験、デプロイ速度、Layer管理が優秀 両方使うことで:✓ 既存資産を活用✓ Lambda開発の生産性向上✓ 責任範囲の明確化 Q2: デプロイとリリースを分離する必要性は？A: ビジネス要件とリスク管理のためです。 必要なケース: 特定時刻にリリースしたい（キャンペーン等） 段階的リリース（カナリア）したい 本番リスクを最小化したい ロールバックを高速化したい 不要なケース: 小規模プロジェクト リリースタイミングが自由 開発スピード最優先 Q3: 既存のTerraform管理Lambdaはどうする？A: 段階的に移行を推奨します。 移行優先順位: 頻繁に変更される関数 Layer管理が必要な関数 新規関数（最初からSAM） その他の関数 移行不要: インフラ系Lambda（認証、監視） ほぼ変更されない関数 Terraformで問題ない関数 Q4: エイリアス管理は必須？A: 推奨しますが、必須ではありません。 エイリアスなしの場合: $LATESTや特定バージョンを直接使用 シンプルだが柔軟性がない ロールバックが面倒 エイリアスありの場合: 環境の明確な分離 瞬時のロールバック トラフィック制御 推奨 Q5: SAMとServerless Frameworkの違いは？A: どちらもLambda管理ツールですが… SAMの特徴:✓ AWS公式✓ CloudFormationベース✓ AWS統合が強い✓ 学習コスト低✓ 本アーキテクチャで推奨 Serverless Frameworkの特徴:✓ マルチクラウド✓ プラグインが豊富✓ コミュニティが大きい✓ AWS以外も視野に入れるなら候補 選択基準: AWS専用 → SAM マルチクラウド → Serverless Framework Q6: コスト増加は？A: わずかに増加しますが、効果が上回ります。 増加要因: SSM Parameter Store（わずか） Lambda バージョン保持（わずか） GitHub Actions実行時間（増加） 削減要因: デプロイ時間短縮 → 人件費削減 障害対応時間短縮 → 機会損失削減 開発速度向上 → 生産性向上 結論:全体としてはコスト削減効果の方が大きい Q7: 小規模プロジェクトでも有効？A: プロジェクト規模より、要件で判断してください。 有効なケース: Lambda関数が10個以上 頻繁にデプロイする 複数チームで開発 Layer管理が必要 ガバナンスが重要 不要なケース: Lambda関数が5個未満 月1回程度のデプロイ 単一チーム シンプルな構成 推奨:Lambda 10個以上 → 本アーキテクチャLambda 10個未満 → シンプルな構成も検討 Q8: セキュリティ上のリスクは？A: 適切に設定すれば、むしろ向上します。 懸念点: 2つのリポジトリ管理 CI/CDでの認証情報 対策:✓ OIDC認証（長期認証情報不要）✓ 最小権限の原則✓ Secrets Manager活用✓ 監査ログ（CloudTrail）✓ 定期的なレビュー 結論:適切に実装すればセキュリティは向上 Q9: ロックイン（ベンダーロック）のリスクは？A: AWS特化ですが、メリットが上回ります。 ロックインの程度: Terraform: 比較的移行しやすい SAM: AWS CloudFormation依存 Lambda自体: AWS固有 緩和策: ビジネスロジックは疎結合に インターフェースを明確に テストコードの充実 実際: 他クラウドへの移行は稀 AWSエコシステムの恩恵が大きい ロックインを過度に恐れる必要なし Q10: 学習コストはどのくらい？A: 経験にもよりますが… 前提知識: Lambda基礎: 必須 Terraform基礎: あると良い GitHub Actions基礎: あると良い 学習時間（目安）: SAM基礎: 2-3日 本アーキテクチャ理解: 1週間 実装習得: 2-4週間 サポート: 本ドキュメント ハンズオン サンプルコード メンター制度 結論:1ヶ月あれば習得可能 まとめメリット（再掲）✓ デプロイとリリースの分離✓ 明確な責任範囲✓ 高速なイテレーション✓ Layer管理の自動化✓ ガバナンスの確保✓ 開発体験の向上✓ 瞬時のロールバック デメリット（再掲）と対策✗ 複雑性の増加 → ドキュメント整備、教育 ✗ リリース待ち時間 → 承認プロセス最適化、緊急フロー ✗ 管理コスト → 自動化、モニタリング ✗ エイリアス手動管理 → スクリプト化、ワークフロー化 推奨する組織最適: Lambda関数 30個以上 複数チーム 既存Terraform資産あり ガバナンス重視 高頻度デプロイ 適用可能: Lambda関数 10-30個 単一チーム デプロイ頻度 中程度 要検討: Lambda関数 10個未満 超シンプルな要件 リソース制約が厳しい 最終的な判断このアーキテクチャを採用すべきか？ YES の場合:✓ スケーラビリティが重要✓ 開発速度を上げたい✓ ガバナンスが必要✓ 既にTerraformを使用✓ Lambda関数が多い（10個以上） NO の場合（代替案検討）: Lambda関数が少ない（5個未満） 超シンプルな要件 学習リソースが限られる → 要件と制約を総合的に判断 全体のまとめ本設計書では、大規模Lambda環境におけるCI/CDアーキテクチャを提示しました。 核心的な価値 適材適所のツール選択 Terraform: インフラ SAM: Lambda デプロイとリリースの分離 リスク管理 ビジネス要件への対応 責任範囲の明確化 インフラチーム アプリケーションチーム スケーラビリティ 関数数の増加 チーム数の増加 ガバナンス 承認フロー 監査証跡 成功の鍵✓ 段階的な導入✓ ドキュメント整備✓ チーム教育✓ 継続的な改善✓ フィードバックループ 次のアクション 本ドキュメントのレビュー パイロットプロジェクト選定 チーム教育の計画 移行計画の策定 実行 参考リンク1234567891011AWS SAM:https://docs.aws.amazon.com/serverless-application-model/Terraform:https://www.terraform.io/docsGitHub Actions:https://docs.github.com/actionsLambda Best Practices:https://docs.aws.amazon.com/lambda/latest/dg/best-practices.html ドキュメント完 本設計書についてのフィードバックや質問は、リポジトリのIssueまでお願いします。","link":"/2025/11/02/lambda-cicd-04-tradeoffs/"},{"title":"miseでのNodeバージョン管理","text":"mise の設定メモ 環境情報 OS macOS Version 15.5 BuildVersion 24F74 インストール12curl https://mise.run | shecho 'eval &quot;$(~/.local/bin/mise activate zsh)&quot;' &gt;&gt; ~/.zshrc インストール確認1mise doctor Node.jsの設定1234mise ls-remote nodemise use node@22.16.0# グローバルの場合mise use -g node@22.16.0 リポジトリ内でのバージョン指定.mise.toml 12[tools]node = &quot;22.16.0&quot; 1mise install","link":"/2025/06/22/mise/"},{"title":"uvでのpythonバージョン管理と仮想環境管理","text":"uv の設定メモ 環境情報 OS macOS Version 15.5 BuildVersion 24F74 インストール1brew install uv プロジェクト初回設定プロジェクトディレクトリで初期化1uv init pyproject.tomlが生成されるため、pythonバージョンを指定 pyproject.toml 1234567...[project]name = &quot;Project Name&quot;version = &quot;0.1.0&quot;description = &quot;Add your description here&quot;readme = &quot;README.md&quot;requires-python = &quot;&gt;=3.13&quot; requirements.txtの取り込み1uv add -r requirements.txt requirements.txtを取り込んだ後は削除してもOK pyproject.tomlをもとにパッケージをインストール1uv sync dependabot.github/dependabot.yml 123456version: 2updates: - package-ecosystem: &quot;uv&quot; # See documentation for possible values directory: &quot;/&quot; # Location of package manifests schedule: interval: &quot;weekly&quot; .gitignore.gitignore 12345...# uv package manager.uv/uv.lock.uvignore 作業開始時仮想環境を有効化1. .venv/bin/activate 作業終了時仮想環境を無効化1deactivate","link":"/2025/06/22/uv/"},{"title":"Lambda CI&#x2F;CD アーキテクチャ - 3. 実装ガイドライン","text":"目次 Terraform実装ガイドライン SAM実装ガイドライン GitHub Actions実装ガイドライン 命名規則とタグ戦略 セキュリティ考慮事項 監視とロギング Terraform実装ガイドライン IAMロール・ポリシー管理基本方針原則:✓ 最小権限の原則（Principle of Least Privilege）✓ ロールベースアクセス制御（RBAC）✓ ポリシーの再利用性✓ 明示的な権限付与 Lambda実行ロールの実装12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697# terraform-infrastructure/iam/lambda-roles.tf# 基本的な実行ロールresource &quot;aws_iam_role&quot; &quot;lambda_execution&quot; { name = &quot;lambda-execution-role&quot; description = &quot;Basic execution role for Lambda functions&quot; assume_role_policy = jsonencode({ Version = &quot;2012-10-17&quot; Statement = [{ Action = &quot;sts:AssumeRole&quot; Effect = &quot;Allow&quot; Principal = { Service = &quot;lambda.amazonaws.com&quot; } }] }) tags = { ManagedBy = &quot;Terraform&quot; Purpose = &quot;LambdaExecution&quot; Environment = var.environment }}# 基本的なロギング権限resource &quot;aws_iam_role_policy_attachment&quot; &quot;lambda_basic_execution&quot; { role = aws_iam_role.lambda_execution.name policy_arn = &quot;arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole&quot;}# VPC内実行の権限resource &quot;aws_iam_role_policy_attachment&quot; &quot;lambda_vpc_execution&quot; { role = aws_iam_role.lambda_execution.name policy_arn = &quot;arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole&quot;}# カスタムポリシー（アプリケーション固有の権限）resource &quot;aws_iam_role_policy&quot; &quot;lambda_application_policy&quot; { name = &quot;lambda-application-policy&quot; role = aws_iam_role.lambda_execution.id policy = jsonencode({ Version = &quot;2012-10-17&quot; Statement = [ # S3アクセス（特定のバケットのみ） { Sid = &quot;S3Access&quot; Effect = &quot;Allow&quot; Action = [ &quot;s3:GetObject&quot;, &quot;s3:PutObject&quot; ] Resource = [ &quot;${aws_s3_bucket.data.arn}/*&quot; ] }, # DynamoDBアクセス（特定のテーブルのみ） { Sid = &quot;DynamoDBAccess&quot; Effect = &quot;Allow&quot; Action = [ &quot;dynamodb:GetItem&quot;, &quot;dynamodb:PutItem&quot;, &quot;dynamodb:Query&quot;, &quot;dynamodb:UpdateItem&quot; ] Resource = [ aws_dynamodb_table.orders.arn, &quot;${aws_dynamodb_table.orders.arn}/index/*&quot; ] }, # Secrets Managerアクセス（特定のシークレットのみ） { Sid = &quot;SecretsManagerAccess&quot; Effect = &quot;Allow&quot; Action = [ &quot;secretsmanager:GetSecretValue&quot; ] Resource = [ aws_secretsmanager_secret.api_keys.arn ] }, # SQS送信（特定のキューのみ） { Sid = &quot;SQSSendMessage&quot; Effect = &quot;Allow&quot; Action = [ &quot;sqs:SendMessage&quot; ] Resource = [ aws_sqs_queue.notifications.arn ] } ] })} 留意点重要な考慮事項: 権限の細分化:問題: 全てのS3バケットへのアクセスを許可解決: 特定のバケット・プレフィックスに限定 悪い例: Resource = “arn:aws:s3:::*” 良い例: Resource = [“${aws_s3_bucket.data.arn}/uploads/“,“${aws_s3_bucket.data.arn}/processed/“ ] 条件付きアクセス:推奨: 条件を使って更に制限 例: VPC内からのみアクセス可能Condition = { StringEquals = {“aws:SourceVpc” = aws_vpc.main.id }} ポリシーのバージョン管理: 変更時は必ずPull Request レビューは複数人で実施 本番適用前にstagingで検証 定期的なレビュー: 四半期ごとに権限を見直し 不要な権限は削除 AWS Access Analyzerを活用 VPC・ネットワーク設定基本構成123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100# terraform-infrastructure/vpc/main.tf# VPCresource &quot;aws_vpc&quot; &quot;main&quot; { cidr_block = var.vpc_cidr enable_dns_hostnames = true enable_dns_support = true tags = { Name = &quot;${var.project_name}-vpc&quot; ManagedBy = &quot;Terraform&quot; Environment = var.environment }}# プライベートサブネット（Lambda用）resource &quot;aws_subnet&quot; &quot;private&quot; { count = length(var.availability_zones) vpc_id = aws_vpc.main.id cidr_block = cidrsubnet(var.vpc_cidr, 4, count.index) availability_zone = var.availability_zones[count.index] tags = { Name = &quot;${var.project_name}-private-${count.index + 1}&quot; Type = &quot;Private&quot; Purpose = &quot;Lambda&quot; ManagedBy = &quot;Terraform&quot; Environment = var.environment }}# Lambda用セキュリティグループresource &quot;aws_security_group&quot; &quot;lambda&quot; { name = &quot;${var.project_name}-lambda-sg&quot; description = &quot;Security group for Lambda functions&quot; vpc_id = aws_vpc.main.id # アウトバウンドは全て許可（インターネット、RDS等へのアクセス） egress { from_port = 0 to_port = 0 protocol = &quot;-1&quot; cidr_blocks = [&quot;0.0.0.0/0&quot;] description = &quot;Allow all outbound traffic&quot; } tags = { Name = &quot;${var.project_name}-lambda-sg&quot; ManagedBy = &quot;Terraform&quot; Environment = var.environment }}# RDS用セキュリティグループresource &quot;aws_security_group&quot; &quot;rds&quot; { name = &quot;${var.project_name}-rds-sg&quot; description = &quot;Security group for RDS&quot; vpc_id = aws_vpc.main.id # Lambdaからのアクセスのみ許可 ingress { from_port = 5432 # PostgreSQL to_port = 5432 protocol = &quot;tcp&quot; security_groups = [aws_security_group.lambda.id] description = &quot;Allow Lambda functions to access RDS&quot; } tags = { Name = &quot;${var.project_name}-rds-sg&quot; ManagedBy = &quot;Terraform&quot; Environment = var.environment }}# NAT Gateway（Lambdaがインターネットにアクセスする場合）resource &quot;aws_eip&quot; &quot;nat&quot; { count = var.enable_nat_gateway ? length(var.availability_zones) : 0 domain = &quot;vpc&quot; tags = { Name = &quot;${var.project_name}-nat-eip-${count.index + 1}&quot; ManagedBy = &quot;Terraform&quot; Environment = var.environment }}resource &quot;aws_nat_gateway&quot; &quot;main&quot; { count = var.enable_nat_gateway ? length(var.availability_zones) : 0 allocation_id = aws_eip.nat[count.index].id subnet_id = aws_subnet.public[count.index].id tags = { Name = &quot;${var.project_name}-nat-${count.index + 1}&quot; ManagedBy = &quot;Terraform&quot; Environment = var.environment }} 留意点VPC設定の注意点: サブネット設計: Lambda用にプライベートサブネットを用意 最低2つのAZ（可用性確保） CIDR範囲は将来の拡張を考慮 NAT Gateway:コスト考慮: development: NAT Gateway なし（VPC外アクセス不要） staging: 1つのNAT Gateway production: AZごとにNAT Gateway（高可用性） 注意: NAT Gatewayは従量課金（$0.045/hour + データ転送費） 本当に必要か検討（VPC Endpointで代替可能な場合も） セキュリティグループ: Lambdaからのアウトバウンドは必要最小限に インバウンドルールは不要（Lambdaは受信しない） 命名規則を統一 VPC Endpoint:推奨: S3、DynamoDB等へのアクセスにVPC Endpointを使用メリット: NAT Gateway不要（コスト削減） レイテンシ改善 セキュリティ向上 例:resource “aws_vpc_endpoint” “s3” { vpc_id = aws_vpc.main.id service_name = “com.amazonaws.ap-northeast-1.s3”} DNS設定: enable_dns_hostnames = true（RDS等の接続に必要） enable_dns_support = true SSM Parameter Store活用命名規則123456789101112131415161718192021222324# 統一された命名規則# 共有値（Terraform → SAM）/shared/{service}/{resource-type}/{name}例:/shared/iam/lambda-execution-role-arn/shared/vpc/private-subnet-ids/shared/vpc/lambda-security-group-id/shared/rds/endpoint/shared/rds/port/shared/rds/database-name/shared/s3/data-bucket-name/shared/dynamodb/orders-table-name/shared/sqs/notification-queue-url/shared/sns/alerts-topic-arn# アプリケーション情報（SAM → Terraform）/apps/{function-name}/{key}例:/apps/user-login-function/latest-version/apps/user-login-function/version-15/metadata/apps/user-login-function/deployed-at 実装パターン123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# terraform-infrastructure/shared-values/main.tflocals { shared_parameters = { # IAM &quot;iam/lambda-execution-role-arn&quot; = aws_iam_role.lambda_execution.arn # VPC &quot;vpc/vpc-id&quot; = aws_vpc.main.id &quot;vpc/private-subnet-ids&quot; = join(&quot;,&quot;, aws_subnet.private[*].id) &quot;vpc/lambda-security-group-id&quot; = aws_security_group.lambda.id # RDS &quot;rds/endpoint&quot; = aws_db_instance.main.endpoint &quot;rds/port&quot; = aws_db_instance.main.port &quot;rds/database-name&quot; = aws_db_instance.main.db_name # S3 &quot;s3/data-bucket-name&quot; = aws_s3_bucket.data.id &quot;s3/uploads-bucket-name&quot; = aws_s3_bucket.uploads.id # DynamoDB &quot;dynamodb/orders-table-name&quot; = aws_dynamodb_table.orders.name &quot;dynamodb/sessions-table-name&quot; = aws_dynamodb_table.sessions.name # SQS &quot;sqs/notification-queue-url&quot; = aws_sqs_queue.notifications.url &quot;sqs/dlq-queue-url&quot; = aws_sqs_queue.dlq.url # SNS &quot;sns/alerts-topic-arn&quot; = aws_sns_topic.alerts.arn }}# 一括作成resource &quot;aws_ssm_parameter&quot; &quot;shared&quot; { for_each = local.shared_parameters name = &quot;/shared/${each.key}&quot; type = each.key == &quot;vpc/private-subnet-ids&quot; ? &quot;StringList&quot; : &quot;String&quot; value = each.value tags = { ManagedBy = &quot;Terraform&quot; Purpose = &quot;SharedConfiguration&quot; Environment = var.environment }} 留意点SSM Parameter Store使用時の注意: タイプの選択: String: 単一の値 StringList: カンマ区切りのリスト（サブネットID等） SecureString: 暗号化が必要な値（パスワード等） 更新の考慮: –overwrite オプションで上書き可能 古い値は履歴として保持されない（注意） 重要な値は別途バックアップ パフォーマンス: SAMデプロイ時に毎回取得 キャッシュされない 大量のパラメータは避ける（必要最小限） コスト: Standard tier: 10,000パラメータまで無料 Advanced tier: $0.05/パラメータ/月 通常はStandardで十分 アクセス制御: IAMポリシーで制御 最小権限の原則 タグベースの制御も可能 SAM実装ガイドラインLambda関数構成ディレクトリ構造1234567891011121314151617functions/├── auth/│ ├── login/│ │ ├── app.py # メインハンドラ│ │ ├── requirements.txt # 依存関係│ │ ├── config.py # 設定│ │ ├── validators.py # バリデーション│ │ └── tests/│ │ ├── test_app.py│ │ └── test_validators.py│ ││ ├── logout/│ └── refresh-token/│└── orders/ ├── create-order/ └── list-orders/ 関数実装のベストプラクティス123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109# functions/auth/login/app.pyimport jsonimport osfrom typing import Dict, Anyfrom company.logger import get_logger # Layerからfrom company.auth import verify_credentials # Layerから# ロガーの初期化（グローバル）logger = get_logger(__name__)# 環境変数の取得（グローバル）DB_ENDPOINT = os.environ['DB_ENDPOINT']TABLE_NAME = os.environ['TABLE_NAME']# 接続の初期化（グローバル、再利用）import boto3dynamodb = boto3.resource('dynamodb')table = dynamodb.Table(TABLE_NAME)def lambda_handler(event: Dict[str, Any], context: Any) -&gt; Dict[str, Any]: &quot;&quot;&quot; Lambda関数のエントリーポイント Args: event: API Gatewayイベント context: Lambdaコンテキスト Returns: API Gatewayレスポンス &quot;&quot;&quot; try: # リクエストのログ logger.info(&quot;Login attempt&quot;, extra={ &quot;request_id&quot;: context.request_id, &quot;source_ip&quot;: event.get('requestContext', {}).get('identity', {}).get('sourceIp') }) # リクエストボディの解析 body = json.loads(event.get('body', '{}')) username = body.get('username') password = body.get('password') # バリデーション if not username or not password: logger.warning(&quot;Missing credentials&quot;) return error_response(400, &quot;Username and password are required&quot;) # 認証処理 if not verify_credentials(username, password): logger.warning(&quot;Invalid credentials&quot;, extra={&quot;username&quot;: username}) return error_response(401, &quot;Invalid credentials&quot;) # セッション作成 session_token = create_session(username) logger.info(&quot;Login successful&quot;, extra={&quot;username&quot;: username}) return { 'statusCode': 200, 'headers': { 'Content-Type': 'application/json', 'Access-Control-Allow-Origin': '*' }, 'body': json.dumps({ 'token': session_token, 'username': username }) } except Exception as e: logger.error(&quot;Login failed&quot;, extra={ &quot;error&quot;: str(e), &quot;request_id&quot;: context.request_id }, exc_info=True) return error_response(500, &quot;Internal server error&quot;)def error_response(status_code: int, message: str) -&gt; Dict[str, Any]: &quot;&quot;&quot;エラーレスポンスの生成&quot;&quot;&quot; return { 'statusCode': status_code, 'headers': { 'Content-Type': 'application/json', 'Access-Control-Allow-Origin': '*' }, 'body': json.dumps({'error': message}) }def create_session(username: str) -&gt; str: &quot;&quot;&quot;セッション作成&quot;&quot;&quot; import uuid from datetime import datetime, timedelta session_token = str(uuid.uuid4()) expiry = datetime.utcnow() + timedelta(hours=24) table.put_item( Item={ 'token': session_token, 'username': username, 'expiry': int(expiry.timestamp()) } ) return session_token 留意点Lambda関数実装のポイント: グローバル変数の活用:理由: コールドスタート時のみ初期化、その後は再利用 推奨: ロガー AWS SDKクライアント（boto3等） データベース接続 設定値 非推奨: リクエスト固有のデータ ステートフルな情報 エラーハンドリング:必須: トップレベルのtry-except 適切なログ出力 ユーザーフレンドリーなエラーメッセージ 内部エラー詳細は隠蔽 タイムアウト設定:考慮事項: 処理時間 + マージン 長すぎると課金増加 短すぎるとタイムアウト頻発 推奨: 軽量API: 3-10秒 データ処理: 30-60秒 バッチ処理: 300-900秒（最大15分） メモリ設定:ポイント: メモリ↑ = CPU性能↑ コストとパフォーマンスのバランス 実測して最適化 開始値: 軽量API: 512MB データ処理: 1024MB 重い処理: 2048MB以上 環境変数:使い分け: 環境ごとに変わる値: 環境変数 機密情報: Secrets Manager / SSM Parameter Store 固定値: コードに埋め込みも可 Layer管理Layer構造12345678910111213141516171819layers/├── dependencies/ # 外部ライブラリ│ ├── python/ # ランタイム別ディレクトリ│ │ └── lib/│ │ └── python3.11/│ │ └── site-packages/│ │ ├── requests/│ │ ├── boto3/│ │ └── ...│ └── requirements.txt│└── company-utils/ # 自社共通コード └── python/ └── company/ ├── __init__.py ├── logger.py ├── auth.py ├── database.py └── validators.py SAMテンプレート123456789101112131415161718192021222324252627# template.yamlResources: # 依存関係Layer（頻繁に更新） DependenciesLayer: Type: AWS::Serverless::LayerVersion Properties: LayerName: !Sub '${AWS::StackName}-dependencies' Description: External dependencies (requests, boto3, etc.) ContentUri: layers/dependencies/ CompatibleRuntimes: - python3.11 RetentionPolicy: Retain Metadata: BuildMethod: python3.11 # 共通ユーティリティLayer（安定） CompanyUtilsLayer: Type: AWS::Serverless::LayerVersion Properties: LayerName: company-utils Description: Company-wide utility functions ContentUri: layers/company-utils/ CompatibleRuntimes: - python3.11 - python3.10 RetentionPolicy: Retain 留意点Layer管理のベストプラクティス: Layer分割戦略:推奨: 外部ライブラリLayer（頻繁に更新） 自社共通コードLayer（安定） 理由: 変更頻度が異なる ビルド時間の最適化 バージョン管理の明確化 サイズ制限:制約: Layer単体: 50MB（圧縮後） 全Layer合計: 250MB（展開後） 対策: 不要なファイル除外（tests/, docs/） 必要なモジュールのみインストール 複数Layerに分割 バージョン管理:重要: Layerは不変（Immutable） 更新時は新バージョン作成 関数は特定バージョンを参照 注意: 古いバージョンは使われなくなったら削除 RetentionPolicy: Retain 推奨 ビルドプロセス:SAMの自動ビルド: BuildMethod指定で自動化 requirements.txt から自動インストール アーキテクチャ考慮（x86_64 / arm64） インポートパス:ポイント: /opt/python がPYTHONPATHに自動追加 from company.logger import … 絶対インポートを使用 互換性:確認事項: CompatibleRuntimes を明示 Pythonバージョンの互換性 ネイティブライブラリの場合はアーキテクチャ エイリアス設定実装パターン123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# template.yamlResources: UserLoginFunction: Type: AWS::Serverless::Function Properties: FunctionName: user-login-function CodeUri: functions/auth/login/ Handler: app.lambda_handler # AutoPublishAliasは使わない # Developmentエイリアス（$LATEST） UserLoginDevAlias: Type: AWS::Lambda::Alias Properties: FunctionName: !Ref UserLoginFunction FunctionVersion: $LATEST Name: development Description: Development environment - always latest code # Stagingエイリアス（自動更新） UserLoginStagingAlias: Type: AWS::Lambda::Alias Properties: FunctionName: !Ref UserLoginFunction FunctionVersion: !GetAtt UserLoginStagingVersion.Version Name: staging Description: !Sub &quot;Staging - Version ${UserLoginStagingVersion.Version}&quot; UserLoginStagingVersion: Type: AWS::Lambda::Version Properties: FunctionName: !Ref UserLoginFunction Description: !Sub | Deployed: ${AWS::StackName} Commit: ${GitCommitSha} Date: ${DeploymentDate} # Productionエイリアス（手動更新） UserLoginProdAlias: Type: AWS::Lambda::Alias Properties: FunctionName: !Ref UserLoginFunction FunctionVersion: &quot;1&quot; # 初期値、後で手動更新 Name: production Description: Production environment DeletionPolicy: Retain UpdateReplacePolicy: Retain 留意点エイリアス設定の注意点: AutoPublishAliasを使わない理由:制約: デプロイ = リリース（分離できない） 細かい制御が困難 複数環境の管理が複雑 代替: AWS::Lambda::Version で明示的に管理 AWS::Lambda::Alias で環境を分離 バージョン番号の扱い:注意: Versionリソースは毎デプロイで新規作成 論理IDが同じでも物理的には別バージョン CloudFormationスタック更新で自動管理 DeletionPolicy:推奨: production: Retain（削除しない） staging: Delete（削除可能） 理由: 本番は誤削除防止 ロールバック用に保持 エイリアス名の統一:規約: development（小文字） staging（小文字） production（小文字） 理由: 全関数で統一 スクリプトで扱いやすい ProvisionedConcurrency:考慮: コールドスタート対策 本番のみ設定（コスト高） 例:UserLoginProdAlias: Properties: ProvisionedConcurrencyConfig: ProvisionedConcurrentExecutions: 5 GitHub Actions実装ガイドラインデプロイワークフローStaging自動デプロイ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168# .github/workflows/deploy-staging.ymlname: Deploy to Stagingon: push: branches: - main paths: - 'functions/**' - 'layers/**' - 'template.yaml' - 'samconfig.toml'env: AWS_REGION: ap-northeast-1 ENVIRONMENT: stagingjobs: deploy: runs-on: ubuntu-latest # 環境の指定（承認不要） environment: name: staging url: https://staging.example.com steps: - name: Checkout code uses: actions/checkout@v4 with: fetch-depth: 0 # 全履歴取得（git diff用） - name: Setup Python uses: actions/setup-python@v5 with: python-version: '3.11' - name: Setup SAM CLI uses: aws-actions/setup-sam@v2 with: version: latest - name: Configure AWS Credentials uses: aws-actions/configure-aws-credentials@v4 with: role-to-assume: ${{ secrets.AWS_LAMBDA_DEPLOY_ROLE }} role-session-name: GitHubActions-Staging aws-region: ${{ env.AWS_REGION }} - name: SAM Build run: | sam build \\ --use-container \\ --parallel - name: SAM Deploy run: | sam deploy \\ --no-confirm-changeset \\ --no-fail-on-empty-changeset \\ --stack-name lambda-app-staging \\ --capabilities CAPABILITY_IAM \\ --region ${{ env.AWS_REGION }} \\ --parameter-overrides \\ Environment=staging - name: Get Function Names id: functions run: | # デプロイされた関数一覧を取得 FUNCTIONS=$(aws cloudformation describe-stack-resources \\ --stack-name lambda-app-staging \\ --query &quot;StackResources[?ResourceType=='AWS::Lambda::Function'].PhysicalResourceId&quot; \\ --output text) echo &quot;functions=$FUNCTIONS&quot; &gt;&gt; $GITHUB_OUTPUT - name: Publish Versions id: versions run: | VERSIONS=&quot;&quot; for FUNCTION in ${{ steps.functions.outputs.functions }}; do VERSION=$(aws lambda publish-version \\ --function-name $FUNCTION \\ --description &quot;Commit: ${{ github.sha }} | Branch: ${{ github.ref_name }}&quot; \\ --query 'Version' \\ --output text) echo &quot;Published $FUNCTION version $VERSION&quot; VERSIONS=&quot;$VERSIONS $FUNCTION:$VERSION&quot; # SSMに保存 aws ssm put-parameter \\ --name &quot;/apps/$FUNCTION/latest-version&quot; \\ --value &quot;$VERSION&quot; \\ --type String \\ --overwrite # メタデータも保存 aws ssm put-parameter \\ --name &quot;/apps/$FUNCTION/version-$VERSION/metadata&quot; \\ --value &quot;{ \\&quot;version\\&quot;: \\&quot;$VERSION\\&quot;, \\&quot;commit\\&quot;: \\&quot;${{ github.sha }}\\&quot;, \\&quot;branch\\&quot;: \\&quot;${{ github.ref_name }}\\&quot;, \\&quot;deployed_at\\&quot;: \\&quot;$(date -u +%Y-%m-%dT%H:%M:%SZ)\\&quot;, \\&quot;deployed_by\\&quot;: \\&quot;${{ github.actor }}\\&quot; }&quot; \\ --type String \\ --overwrite done echo &quot;versions=$VERSIONS&quot; &gt;&gt; $GITHUB_OUTPUT - name: Run Smoke Tests run: | # 基本的な疎通確認 for FUNCTION in ${{ steps.functions.outputs.functions }}; do echo &quot;Testing $FUNCTION...&quot; aws lambda invoke \\ --function-name $FUNCTION:staging \\ --payload '{&quot;test&quot;: true}' \\ --log-type Tail \\ response.json # レスポンス確認 if grep -q &quot;errorMessage&quot; response.json; then echo &quot;❌ Smoke test failed for $FUNCTION&quot; cat response.json exit 1 fi echo &quot;✅ Smoke test passed for $FUNCTION&quot; done - name: Notify Slack if: always() uses: slackapi/slack-github-action@v1 with: webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }} payload: | { &quot;text&quot;: &quot;${{ job.status == 'success' &amp;&amp; '✅' || '❌' }} Staging Deployment&quot;, &quot;blocks&quot;: [ { &quot;type&quot;: &quot;section&quot;, &quot;text&quot;: { &quot;type&quot;: &quot;mrkdwn&quot;, &quot;text&quot;: &quot;*Staging Deployment ${{ job.status }}*\\n\\n*Commit:* ${{ github.sha }}\\n*Branch:* ${{ github.ref_name }}\\n*Author:* ${{ github.actor }}\\n*Versions:* ${{ steps.versions.outputs.versions }}&quot; } }, { &quot;type&quot;: &quot;actions&quot;, &quot;elements&quot;: [ { &quot;type&quot;: &quot;button&quot;, &quot;text&quot;: {&quot;type&quot;: &quot;plain_text&quot;, &quot;text&quot;: &quot;View Workflow&quot;}, &quot;url&quot;: &quot;${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}&quot; }, { &quot;type&quot;: &quot;button&quot;, &quot;text&quot;: {&quot;type&quot;: &quot;plain_text&quot;, &quot;text&quot;: &quot;Request Production Release&quot;}, &quot;url&quot;: &quot;${{ github.server_url }}/${{ github.repository }}/actions/workflows/release-production.yml&quot;, &quot;style&quot;: &quot;primary&quot; } ] } ] } Production手動リリース123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200# .github/workflows/release-production.ymlname: Release to Productionon: workflow_dispatch: inputs: function_name: description: 'Function name to release' required: true type: choice options: - user-login-function - user-logout-function - create-order-function - process-payment-function version: description: 'Version number to release (from staging)' required: true type: string strategy: description: 'Release strategy' required: true type: choice options: - immediate - canary-10 - blue-green default: canary-10env: AWS_REGION: ap-northeast-1jobs: validate: runs-on: ubuntu-latest outputs: current_version: ${{ steps.current.outputs.version }} metadata: ${{ steps.metadata.outputs.data }} steps: - name: Configure AWS Credentials uses: aws-actions/configure-aws-credentials@v4 with: role-to-assume: ${{ secrets.AWS_LAMBDA_DEPLOY_ROLE }} aws-region: ${{ env.AWS_REGION }} - name: Get Current Production Version id: current run: | CURRENT=$(aws lambda get-alias \\ --function-name ${{ inputs.function_name }} \\ --name production \\ --query 'FunctionVersion' \\ --output text) echo &quot;version=$CURRENT&quot; &gt;&gt; $GITHUB_OUTPUT echo &quot;Current production version: $CURRENT&quot; - name: Validate New Version Exists run: | aws lambda get-function \\ --function-name ${{ inputs.function_name }} \\ --qualifier ${{ inputs.version }} echo &quot;✅ Version ${{ inputs.version }} exists&quot; - name: Get Version Metadata id: metadata run: | METADATA=$(aws ssm get-parameter \\ --name &quot;/apps/${{ inputs.function_name }}/version-${{ inputs.version }}/metadata&quot; \\ --query 'Parameter.Value' \\ --output text 2&gt;/dev/null || echo '{}') echo &quot;data=$METADATA&quot; &gt;&gt; $GITHUB_OUTPUT echo &quot;Version metadata:&quot; echo &quot;$METADATA&quot; | jq . approve: needs: validate runs-on: ubuntu-latest # 本番環境（承認必須） environment: name: production url: https://production.example.com steps: - name: Approval Required run: | echo &quot;⏳ Waiting for approval to release to production&quot; echo &quot;Function: ${{ inputs.function_name }}&quot; echo &quot;Version: ${{ inputs.version }}&quot; echo &quot;Current: ${{ needs.validate.outputs.current_version }}&quot; echo &quot;Strategy: ${{ inputs.strategy }}&quot; release: needs: [validate, approve] runs-on: ubuntu-latest steps: - name: Checkout scripts uses: actions/checkout@v4 with: sparse-checkout: | scripts/ - name: Configure AWS Credentials uses: aws-actions/configure-aws-credentials@v4 with: role-to-assume: ${{ secrets.AWS_LAMBDA_DEPLOY_ROLE }} aws-region: ${{ env.AWS_REGION }} - name: Release - Immediate if: inputs.strategy == 'immediate' run: | aws lambda update-alias \\ --function-name ${{ inputs.function_name }} \\ --name production \\ --function-version ${{ inputs.version }} echo &quot;✅ Immediately released version ${{ inputs.version }}&quot; - name: Release - Canary 10% if: inputs.strategy == 'canary-10' run: | echo &quot;Phase 1: Route 10% traffic to new version&quot; aws lambda update-alias \\ --function-name ${{ inputs.function_name }} \\ --name production \\ --function-version ${{ needs.validate.outputs.current_version }} \\ --routing-config &quot;{\\&quot;AdditionalVersionWeights\\&quot;: {\\&quot;${{ inputs.version }}\\&quot;: 0.1}}&quot; echo &quot;Monitoring for 10 minutes...&quot; sleep 600 # メトリクスをチェック ERROR_RATE=$(aws cloudwatch get-metric-statistics \\ --namespace AWS/Lambda \\ --metric-name Errors \\ --dimensions Name=FunctionName,Value=${{ inputs.function_name }} Name=Resource,Value=${{ inputs.function_name }}:production \\ --start-time $(date -u -d '10 minutes ago' +%Y-%m-%dT%H:%M:%S) \\ --end-time $(date -u +%Y-%m-%dT%H:%M:%S) \\ --period 600 \\ --statistics Sum \\ --query 'Datapoints[0].Sum' \\ --output text) echo &quot;Error count in last 10 minutes: $ERROR_RATE&quot; if [ &quot;$ERROR_RATE&quot; != &quot;None&quot; ] &amp;&amp; [ &quot;$ERROR_RATE&quot; -gt 10 ]; then echo &quot;❌ Error rate too high! Rolling back...&quot; aws lambda update-alias \\ --function-name ${{ inputs.function_name }} \\ --name production \\ --function-version ${{ needs.validate.outputs.current_version }} exit 1 fi echo &quot;Phase 2: Route 100% traffic to new version&quot; aws lambda update-alias \\ --function-name ${{ inputs.function_name }} \\ --name production \\ --function-version ${{ inputs.version }} echo &quot;✅ Canary release completed successfully&quot; - name: Verify Release run: | CURRENT=$(aws lambda get-alias \\ --function-name ${{ inputs.function_name }} \\ --name production \\ --query 'FunctionVersion' \\ --output text) if [ &quot;$CURRENT&quot; == &quot;${{ inputs.version }}&quot; ]; then echo &quot;✅ Production is now running version ${{ inputs.version }}&quot; else echo &quot;❌ Verification failed - production version is $CURRENT&quot; exit 1 fi - name: Notify Slack if: always() uses: slackapi/slack-github-action@v1 with: webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }} payload: | { &quot;text&quot;: &quot;${{ job.status == 'success' &amp;&amp; '✅' || '❌' }} Production Release&quot;, &quot;blocks&quot;: [ { &quot;type&quot;: &quot;section&quot;, &quot;text&quot;: { &quot;type&quot;: &quot;mrkdwn&quot;, &quot;text&quot;: &quot;*Production Release ${{ job.status }}*\\n\\n*Function:* ${{ inputs.function_name }}\\n*Version:* ${{ inputs.version }}\\n*Previous:* ${{ needs.validate.outputs.current_version }}\\n*Strategy:* ${{ inputs.strategy }}\\n*Approved by:* ${{ github.actor }}&quot; } } ] } 変更検知とパス指定効率的なデプロイ1234567891011121314151617181920212223242526272829303132333435363738394041# 変更されたファイルに応じてジョブを実行on: push: branches: [main]jobs: detect-changes: runs-on: ubuntu-latest outputs: functions: ${{ steps.filter.outputs.functions }} layers: ${{ steps.filter.outputs.layers }} template: ${{ steps.filter.outputs.template }} steps: - uses: actions/checkout@v4 with: fetch-depth: 0 - uses: dorny/paths-filter@v2 id: filter with: filters: | functions: - 'functions/**' layers: - 'layers/**' template: - 'template.yaml' - 'samconfig.toml' deploy: needs: detect-changes if: | needs.detect-changes.outputs.functions == 'true' || needs.detect-changes.outputs.layers == 'true' || needs.detect-changes.outputs.template == 'true' runs-on: ubuntu-latest steps: # デプロイ処理 命名規則とタグ戦略リソース命名規則1234567891011121314151617181920212223242526272829303132基本パターン:{project}-{resource-type}-{environment}-{purpose}例:- myapp-lambda-prod-user-auth- myapp-rds-prod-main- myapp-s3-prod-dataLambda関数:{purpose}-function例:- user-login-function- create-order-function- process-payment-functionLayer:{purpose}-layer例:- dependencies-layer- company-utils-layerエイリアス:- development- staging- production（全て小文字、統一）SSMパラメータ:/shared/{service}/{resource-type}/{name}/apps/{function-name}/{key} タグ戦略123456789101112131415161718192021# 全リソース共通タグlocals { common_tags = { Project = var.project_name Environment = var.environment ManagedBy = &quot;Terraform&quot; # or &quot;SAM&quot; Team = var.team_name CostCenter = var.cost_center }}# リソース固有タグresource &quot;aws_lambda_function&quot; &quot;example&quot; { tags = merge( local.common_tags, { Purpose = &quot;UserAuthentication&quot; Runtime = &quot;Python3.11&quot; } )} セキュリティ考慮事項OIDC認証の設定12345678910111213141516171819202122232425262728293031323334353637383940414243# GitHub ActionsからAWSへの認証# Terraform側resource &quot;aws_iam_openid_connect_provider&quot; &quot;github&quot; { url = &quot;https://token.actions.githubusercontent.com&quot; client_id_list = [ &quot;sts.amazonaws.com&quot; ] thumbprint_list = [ &quot;6938fd4d98bab03faadb97b34396831e3780aea1&quot; ]}resource &quot;aws_iam_role&quot; &quot;github_actions&quot; { name = &quot;github-actions-lambda-deploy&quot; assume_role_policy = jsonencode({ Version = &quot;2012-10-17&quot; Statement = [{ Effect = &quot;Allow&quot; Principal = { Federated = aws_iam_openid_connect_provider.github.arn } Action = &quot;sts:AssumeRoleWithWebIdentity&quot; Condition = { StringEquals = { &quot;token.actions.githubusercontent.com:aud&quot; = &quot;sts.amazonaws.com&quot; } StringLike = { &quot;token.actions.githubusercontent.com:sub&quot; = &quot;repo:your-org/lambda-applications:*&quot; } } }] })}# GitHub Actions側- uses: aws-actions/configure-aws-credentials@v4 with: role-to-assume: arn:aws:iam::123456789012:role/github-actions-lambda-deploy aws-region: ap-northeast-1 シークレット管理推奨: GitHub Secrets: AWS Role ARN Slack Webhook URL AWS Secrets Manager: データベースパスワード API Key OAuth Token SSM Parameter Store (SecureString): 設定値（機密） 証明書 非推奨:❌ コードに直接埋め込み❌ 環境変数に平文❌ Gitにコミット 監視とロギングCloudWatch設定123456789101112131415161718# SAMResources: MyFunction: Type: AWS::Serverless::Function Properties: # ログ設定 LoggingConfig: LogFormat: JSON LogGroup: !Ref MyFunctionLogGroup # トレーシング Tracing: Active # X-Ray有効化 MyFunctionLogGroup: Type: AWS::Logs::LogGroup Properties: LogGroupName: !Sub '/aws/lambda/${MyFunction}' RetentionInDays: 7 # staging: 7日、production: 30日 アラーム設定12345678910111213141516171819# Terraformresource &quot;aws_cloudwatch_metric_alarm&quot; &quot;lambda_errors&quot; { alarm_name = &quot;${var.function_name}-errors&quot; comparison_operator = &quot;GreaterThanThreshold&quot; evaluation_periods = 2 metric_name = &quot;Errors&quot; namespace = &quot;AWS/Lambda&quot; period = 60 statistic = &quot;Sum&quot; threshold = 10 alarm_description = &quot;Lambda function error rate&quot; dimensions = { FunctionName = var.function_name Resource = &quot;${var.function_name}:production&quot; } alarm_actions = [aws_sns_topic.alerts.arn]} 次のステップ実装のガイドラインを理解したら、メリット・デメリットを確認します。 👉 次へ: 4. メリットとデメリットとして認識すべきこと","link":"/2025/11/02/lambda-cicd-03-implementation/"},{"title":"SlackのIncoming Webhooksについて","text":"自分の知っていたSlackのIncoming-WebhookはLegacyとしてかなり前に非推奨になっていた話。 サポートに関する情報Discontinuing support for legacy custom bots and classic appsによれば 2024年6月: 新しいlegacy appsとclassic appsの作成をブロック開始 2025年3月31日: legacy custom botsのサポート終了 2026年5月25日: classic appsのサポート終了 公開されているスケジュールは上記のもので、Legacy Custom Integrationsにあたる、Legacy Incoming Webhookは明確に期日を決められているわけではなさそうです。色々と仕様の変更については書かれていますが、基本的にはpayloadとして互換性もあるので、ひとまず移行してしまった方が無難という結論です。 Legacy Incoming Webhook と Incoming WebhookLegacy Incoming Webhook Incoming Webhookでアプリを検索すると表示されます We do not recommend their use. という注意書きが上部にあります 設定画面が１画面で完結し、非常にシンプルでわかりやすく設定できます Incoming Webhook Slack AppをにてCreate New Appを選択 From scratchを選択、App Nameとworkspaceを入力してCreate Basic InformationのDisplay Informationを入力 Features &gt; Incoming Webhooks Activate Incoming Webhooks を On にします Add New Webhookで、URLをchannelごとに作成します それぞれの違い Legacy Incoming Webhook ペイロード内でusername、icon、channelを上書きできる URL知ってたらどのchannelでも書き込めるわけで、あまりよくない仕様ですね 作成者が組織を離れるとWebhookが無効化される管理上の問題があります レイアウトはattachmentsで表現します Incoming Webhook レイアウトはBlock Kitを使用してより高度なメッセージ作成が可能です 移行方法はMigrate your legacy message compositions to blocks ただし、attachmentsも非推奨ですが、使えるので互換性は担保されそうです 特に色指定はattachmentsしか表現できず、メッセージの緊急度で色分けしたいケース（監視アラート等）では使うしかありません 色指定にgood/warning/dangerは使えないという情報を見かけましたが、問題なく使えました。カラーコードもOK（例：#ff0000） attachmentsでのテストペイロード 1234567891011curl -X POST -H 'Content-type: application/json' \\ --data '{ &quot;text&quot;: &quot;Hello, World!&quot;, &quot;attachments&quot;: [ { &quot;color&quot;: &quot;good&quot;, &quot;text&quot;: &quot;This is a test message&quot; } ] }' \\ https://{YOUR_WEBHOOK_URL}","link":"/2025/06/25/slack_webhooks/"},{"title":"zed editorでのBedrock接続（Proxy経由）","text":"zed でAmazon Bedrock接続（Proxy経由）の設定メモ 環境情報 OS macOS Version 15.5 前提 AWS CLIがインストールされ、プロファイル設定が完了していること Bedrockのモデル有効化AWSマネジメントコンソールで利用したいRegionでBedrockの画面へアクセス“Bedrock configurations” &gt; “モデルアクセス” で有効化したいモデルをリクエスト Zed でのBedrockの設定 Authentication via Named Profile (Recommended) Network Proxy Setting.jsonを編集 1234567&quot;language_models&quot;: { &quot;bedrock&quot;: { &quot;authentication_method&quot;: &quot;named_profile&quot;, &quot;region&quot;: &quot;{your-aws-region}}&quot;, &quot;profile&quot;: &quot;{your-profile-name}&quot; },&quot;proxy&quot;: &quot;http://username:password@proxyserver:port&quot; 設定後、必ずZedの再起動が必要","link":"/2025/06/22/zed_bedrock/"},{"title":"zshとbashは違う","text":"jqを使った時に気づいた話 bashはデフォルトで.items[]をリテラルな文字列として扱います。 123# bashecho '{&quot;items&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]}' | jq -r .items[] | xargs echoa b c zshはデフォルトで、クォートされていない引数をグロブパターンとして扱おうとします。 123# zshecho '{&quot;items&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]}' | jq -r .items[] | xargs echozsh: no matches found: .items[] zshでこのコマンドを正しく動作させるには、.items[]をクォートで囲む必要があります。 12echo '{&quot;items&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]}' | jq -r '.items[]' | xargs echoa b c shellcheckを使うと安心Macのインストールは以下のコマンドです 1brew install shellcheck","link":"/2024/09/07/zsh_bash/"}],"tags":[{"name":"Route53","slug":"Route53","link":"/tags/Route53/"},{"name":"DNS","slug":"DNS","link":"/tags/DNS/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"sshd","slug":"sshd","link":"/tags/sshd/"},{"name":"AWS Lambda","slug":"AWS-Lambda","link":"/tags/AWS-Lambda/"},{"name":"CI&#x2F;CD","slug":"CI-CD","link":"/tags/CI-CD/"},{"name":"Terraform","slug":"Terraform","link":"/tags/Terraform/"},{"name":"SAM","slug":"SAM","link":"/tags/SAM/"},{"name":"GitHub Actions","slug":"GitHub-Actions","link":"/tags/GitHub-Actions/"},{"name":"アーキテクチャ","slug":"アーキテクチャ","link":"/tags/%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3/"},{"name":"インフラ","slug":"インフラ","link":"/tags/%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"mise","slug":"mise","link":"/tags/mise/"},{"name":"uv","slug":"uv","link":"/tags/uv/"},{"name":"Slack","slug":"Slack","link":"/tags/Slack/"},{"name":"Zed","slug":"Zed","link":"/tags/Zed/"},{"name":"Bedrock","slug":"Bedrock","link":"/tags/Bedrock/"},{"name":"zsh","slug":"zsh","link":"/tags/zsh/"},{"name":"bash","slug":"bash","link":"/tags/bash/"}],"categories":[{"name":"DNS","slug":"DNS","link":"/categories/DNS/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"AWS","slug":"AWS","link":"/categories/AWS/"},{"name":"Node.js","slug":"Node-js","link":"/categories/Node-js/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"DevOps","slug":"AWS/DevOps","link":"/categories/AWS/DevOps/"},{"name":"Slack","slug":"Slack","link":"/categories/Slack/"},{"name":"Zed","slug":"Zed","link":"/categories/Zed/"},{"name":"Mac","slug":"Mac","link":"/categories/Mac/"}],"pages":[]}