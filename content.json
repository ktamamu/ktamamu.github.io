{"posts":[{"title":"","text":"","link":"/2025/12/07/cloud_flare_email_routing/"},{"title":"Route53とオンプレDNSにおける条件付きフォワーダーと委任の構成比較","text":"Route 53 リゾルバーのエンドポイントを使ったプライベートホストゾーンへのサブドメインの委任について、Qiita(※)で解説記事を拝見してその構成を条件付きフォワーダーと比べるとどうなるか構成図に表してみました。 これまではオンプレ環境の独自ドメインの権威 DNS サーバで管理しているドメインがあり、AWSのRoute53でサブドメインを管理したい場合、Route 53 インバウンドエンドポイントへオンプレミスからの名前解決クエリを転送する必要がありました。（条件付きフォワーダー設定） Route 53 リゾルバーのプライベートホストゾーンへのサブドメインの委任を設定することができるようになりました。 Amazon Route 53 Resolver endpoints now support DNS delegation for private hosted zones 標準的なDNS委任構成となるので、条件付きフォワーダーよりも委任設定が推奨ですが、Route 53 インバウンドエンドポイントの再作成にはネットワーク停止を伴う点は注意が必要です。 (※)Route 53 プライベートホストゾーンへオンプレミスの DNS サーバーからサブドメインを委任できるようになったので試してみた","link":"/2025/06/29/dns_forward/"},{"title":"sshdの接続元を日本のIPに限定する","text":"fetus 国／地域別IPアドレス割り振り一覧 のIPリストを取得し、SSHの接続元を日本のIPに限定 環境情報 OS Ubuntu Version 24.04.2 LTS hosts.allowとhosts.denyの設定 最終行は改行が必要です（改行がないと正常に動作しません） /etc/hosts.allow 12sshd: /etc/jp.allow /etc/hosts.deny 12ALL : ALL スクリプト必要なライブラリの取得します 1pip install requests jp_allow.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import requests# IPリストを取得するURLURL = &quot;https://ipv4.fetus.jp/jp.txt&quot;def convert_subnet(cidr_value): ''' サブネットを255.255.255.0形式に変換する関数 ''' subnet_map = { 8: &quot;255.0.0.0&quot;, 9: &quot;255.128.0.0&quot;, 10: &quot;255.192.0.0&quot;, 11: &quot;255.224.0.0&quot;, 12: &quot;255.240.0.0&quot;, 13: &quot;255.248.0.0&quot;, 14: &quot;255.252.0.0&quot;, 15: &quot;255.254.0.0&quot;, 16: &quot;255.255.0.0&quot;, 17: &quot;255.255.128.0&quot;, 18: &quot;255.255.192.0&quot;, 19: &quot;255.255.224.0&quot;, 20: &quot;255.255.240.0&quot;, 21: &quot;255.255.248.0&quot;, 22: &quot;255.255.252.0&quot;, 23: &quot;255.255.254.0&quot;, 24: &quot;255.255.255.0&quot;, 25: &quot;255.255.255.128&quot;, 26: &quot;255.255.255.192&quot;, 27: &quot;255.255.255.224&quot;, 28: &quot;255.255.255.240&quot;, 29: &quot;255.255.255.248&quot;, 30: &quot;255.255.255.252&quot;, 31: &quot;255.255.255.254&quot;, 32: &quot;255.255.255.255&quot; } return subnet_map.get(cidr_value)# URLからデータを取得response = requests.get(URL, timeout=5)ip_data = response.text.splitlines()# jp.allow形式に変換with open(&quot;/etc/jp.allow&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as file: output = [] for line in ip_data: if line and not line.startswith(&quot;#&quot;): # コメント行をスキップ ip, cidr = line.split('/') subnet = convert_subnet(int(cidr)) output.append(f&quot;{ip}/{subnet}&quot;) file.write(&quot; &quot;.join(output)) # スペースで区切って書き込みprint(&quot;IPリストがjp.allowファイルに変換されました。&quot;) 実行 /etc に書き込むため管理者権限が必要です 1sudo python jp_allow.py 注意 hosts.allowとhosts.denyは接続の度に動的に読み込まれるので、別ターミナル等で試行してからセッションを切断してください","link":"/2025/06/23/jp_allow/"},{"title":"Lambda CI&#x2F;CD アーキテクチャ - 目次","text":"このシリーズについてAWS Lambdaの大規模運用において、デプロイとリリースを分離し、安全で高速なCI/CDを実現するアーキテクチャを解説します。 本記事はAI(Claude)を活用して執筆しています。内容の正確性については保証いたしかねますので、重要な情報は必ず一次情報源をご確認ください。 対象読者 Lambda関数が20個以上ある環境を運用している方 デプロイ頻度を上げたいが、本番障害のリスクを懸念している方 TerraformとLambdaツールの使い分けに悩んでいる方 インフラチームとアプリチームの責任分離を明確にしたい方 前提知識 AWS Lambda、Terraform、GitHub Actionsの基本的な理解 CI/CDの概念 Infrastructure as Codeの経験 全体構成1. CI/CD環境構築における方針何を解決するのか、なぜこの設計なのか デプロイとリリースの分離とは TerraformとLambrollの使い分け エイリアス戦略の核心 設計の3原則 読了時間: 5分 2. 構成要素と役割システム全体像と各コンポーネントの責任 アーキテクチャ図（SVG） リポジトリ構成 Terraform vs Lambrollの責任範囲 リソース配置のルール エイリアス管理戦略 読了時間: 10分 3. 実装ガイドライン実際に構築する際の具体的な手順 Terraform実装（インフラ、IAM、outputs） Lambroll実装（function.jsonl、Layer戦略） GitHub Actions設定 バージョン削除の自動化 アーティファクト管理 読了時間: 15分 4. トレードオフと運用上の考慮点採用判断のための現実的な評価 メリット・デメリット 適用すべき規模 失敗パターン 段階的な導入戦略 よくある質問（FAQ） 読了時間: 8分 このアーキテクチャの特徴 実現すること 高速なデプロイ: mainへのpushから2分以内にstagingへ反映 安全なリリース: 手動承認により本番への影響を制御 瞬時のロールバック: エイリアス切替で5秒以内に前バージョンへ復帰 明確な責任分離: インフラチーム（Terraform）とアプリチーム（Lambroll） カナリアリリース: 段階的なトラフィック制御によるリスク最小化 核心のコンセプトデプロイ ≠ リリース デプロイ: コードをLambdaにアップロード → 自動化 リリース: ユーザーに公開（エイリアス切替） → 手動承認 この分離により、開発速度と本番安全性を両立します。 技術スタック レイヤー ツール 役割 インフラ Terraform VPC、IAM、RDS、S3、EventBridge等 Lambda Lambroll 関数コード、設定、エイリアス CI/CD GitHub Actions 自動デプロイ、手動承認フロー 連携 Terraform outputs インフラ情報の受け渡し アーティファクト S3 + Versioning デプロイパッケージの保管 想定する環境規模 このアーキテクチャが有効 Lambda関数: 20個以上 デプロイ頻度: 週5回以上 チーム規模: 3人以上（インフラ + アプリ開発） 本番環境: ダウンタイム許容不可 オーバーエンジニアリングになるケース Lambda関数: 10個未満 個人プロジェクト 月1回程度のリリース頻度 PoC・検証環境 → この場合はTerraformのみで十分です 読み進め方のガイド まずは全体像を把握したい → 1章（方針） → 2章（構成要素） のアーキテクチャ図 → 4章（FAQ） 実際に構築したい → 2章（構成要素） でリポジトリ構成を理解 → 3章（実装ガイド） を順に実施 → 4章（運用考慮点） で落とし穴を確認 採用判断をしたい → 1章（方針） で設計思想を理解 → 4章（トレードオフ） でメリット・デメリットを評価 → 自環境の規模と照らし合わせて判断 補足資料関連ドキュメント Terraform公式ドキュメント Lambroll GitHub AWS Lambda Versions and Aliases サンプルコード実装例は各章に掲載していますが、完全なサンプルリポジトリは以下を参照： terraform-infrastructure（準備中） lambda-applications（準備中） 更新履歴 2025-11-02: 初版公開（SAM版） 2025-11-XX: Lambroll版に全面改訂 それでは、方針の章から始めましょう。 1. CI/CD環境構築における方針","link":"/2025/11/02/lambda-cicd-00-index/"},{"title":"Lambda CI&#x2F;CD アーキテクチャ - 1. CI&#x2F;CD環境構築における方針","text":"ドキュメント構成 → 1. CI/CD環境構築における方針 2. 構成要素と役割 3. 実装ガイドライン 4. トレードオフと運用上の考慮点 免責事項本記事はAI(Claude)を活用して執筆しています。内容の正確性については保証いたしかねますので、重要な情報は必ず一次情報源をご確認ください。 この章で理解することなぜこの設計なのか？ の答えがここにあります。 デプロイとリリースの分離 TerraformとLambrollの使い分けの本質 エイリアス戦略が全ての鍵 設計の3つの原則 デプロイとリリースの分離従来の課題多くのLambda環境では、デプロイ = リリース となっています。 123コード変更 → デプロイ → 即座に本番反映 ↑ 危険！ 問題点: 本番環境でいきなりコードが実行される 問題発見時のロールバックに時間がかかる テスト環境と本番環境の切り替えが曖昧 解決策: エイリアスによる分離12345678910デプロイ: Lambda関数にコードをアップロード ↓ （バージョン16が作成される） ↓stagingエイリアス → v16 に自動更新productionエイリアス → v15 のまま（手動まで待機） ↓ （QA・検証） ↓手動承認 → productionエイリアス → v16 に更新 メリット: デプロイしても本番に影響なし staging環境で十分に検証 リリースは承認後に即座に実行（エイリアス切替のみ） ロールバックも瞬時（エイリアスを戻すだけ） TerraformとLambrollの使い分けなぜ2つのツールを使うのか？核心: 変更頻度とライフサイクルの違い 特性 Terraform Lambroll 変更頻度 低い（月1回以下） 高い（日5回以上） 管理対象 インフラ全般 Lambda関数のみ 実行時間 長い（10-30分） 短い（1-3分） 影響範囲 広い（全体） 狭い（特定関数） Terraform: インフラの真実の源泉責任範囲: VPC、Subnet、Security Group IAM Role、Policy RDS、DynamoDB（共有） S3 Bucket EventBridge、SQS/SNS（共有） Lambda Layer（ARNのみ） なぜTerraformで管理？ 変更が稀 → 慎重な変更管理が必要 複数サービスで共有 → 一元管理 セキュリティ重要 → インフラチームが管理 Lambroll: Lambda関数に特化責任範囲: Lambda関数のコード 関数設定（function.jsonl） エイリアス管理 なぜLambrollを選んだのか？ SAMではなくLambrollを採用した理由： インフラリソースを管理しない SAM: IAM、VPC等も管理 → Terraformと重複 Lambroll: Lambda関数のみ → 責任が明確 Terraform stateを直接参照 SAM: SSM Parameter Store経由で連携 Lambroll: terraform outputを環境変数で参照 → シンプル 軽量で高速 SAM: CloudFormation経由（遅い） Lambroll: AWS API直接（速い） 例: function.jsonl 1234567891011121314{ &quot;FunctionName&quot;: &quot;user-auth-function&quot;, &quot;Runtime&quot;: &quot;python3.11&quot;, &quot;Role&quot;: &quot;{{ must_env `TF_ROLE_ARN` }}&quot;, &quot;VpcConfig&quot;: { &quot;SubnetIds&quot;: {{ env `TF_SUBNET_IDS` | json_array }}, &quot;SecurityGroupIds&quot;: {{ env `TF_SG_IDS` | json_array }} }, &quot;Environment&quot;: { &quot;Variables&quot;: { &quot;DB_ENDPOINT&quot;: &quot;{{ must_env `TF_RDS_ENDPOINT` }}&quot; } }} Terraform outputsを環境変数として直接参照できます。 エイリアス戦略の核心エイリアスとはLambda関数の特定バージョンへの名前付きポインタです。 1234567891011Lambda関数: user-auth-function├── $LATEST（常に最新コード）├── Version 1├── Version 2...├── Version 15（現在の本番）├── Version 16（新バージョン）└── Aliases（ポインタ） ├── development → $LATEST ├── staging → Version 16 └── production → Version 15 3環境の戦略Development環境1development エイリアス → $LATEST 常に最新コードを参照 開発者の動作確認用 不安定でも問題なし Staging環境1staging エイリアス → 最新Version（自動更新） mainブランチにmerge → 自動デプロイ → Version発行 → staging更新 QA・統合テスト用 本番リリース前の最終確認 Production環境1production エイリアス → 承認されたVersion（手動更新） staging検証完了 → 手動承認 → production更新 エンドユーザー向け 最も慎重に管理 なぜこの戦略なのか？開発速度 × 本番安全性 の両立 Development: 制約なし → 開発速度最大化 Staging: 自動化 → 検証サイクル高速化 Production: 手動承認 → リスク最小化 設計の3原則原則1: 単一責任の原則各ツールは1つの責任のみを持つ 1234567891011Terraform: ✓ インフラ管理 ✗ Lambda関数のコードLambroll: ✓ Lambda関数 ✗ インフラリソースGitHub Actions: ✓ CI/CDパイプライン ✗ リソース管理 メリット: 変更の影響範囲が明確 トラブルシューティングが容易 チーム間の責任分界点が明確 原則2: 疎結合の原則コンポーネント間は間接的に連携 12345Terraform outputs ↓環境変数 ↓Lambroll メリット: Terraformの変更がLambrollに影響しない 独立してデプロイ可能 テストが容易 原則3: 不変性の原則Lambda Versionは不変 123Version 15 → 一度作成したら変更不可 ↓ 削除のみ可能 メリット: ロールバックが確実 監査証跡が残る エイリアスの切替のみでリリース・ロールバック まとめこの設計の核心エイリアスによる環境分離 + ツールの責任分離 1234567891011121314151617181920┌─────────────────────────────────┐│ Terraform（インフラ） ││ - VPC, IAM, RDS, S3... ││ - 変更が稀 ││ - インフラチームが管理 │└─────────────────────────────────┘ ↓ outputs┌─────────────────────────────────┐│ Lambroll（Lambda関数） ││ - コード、設定 ││ - 頻繁に変更 ││ - アプリチームが管理 │└─────────────────────────────────┘ ↓ deploy┌─────────────────────────────────┐│ Lambda Versions + Aliases ││ - development → $LATEST ││ - staging → v16（自動） ││ - production → v15（手動） │└─────────────────────────────────┘ 実現すること 高速デプロイ: 2分以内 安全リリース: 手動承認 瞬時ロールバック: 5秒以内 明確な責任: チーム間の分業 段階的展開: カナリアリリース 次のステップ方針を理解したら、具体的な構成要素を見ていきましょう。 次へ: 2. 構成要素と役割","link":"/2025/11/02/lambda-cicd-01-principles/"},{"title":"Lambda CI&#x2F;CD アーキテクチャ - 2. 構成要素と役割","text":"ドキュメント構成 1. CI/CD環境構築における方針 → 2. 構成要素と役割 3. 実装ガイドライン 4. トレードオフと運用上の考慮点 免責事項本記事はAI(Claude)を活用して執筆しています。内容の正確性については保証いたしかねますので、重要な情報は必ず一次情報源をご確認ください。 この章で理解することシステム全体の構成と、各コンポーネントの責任範囲を明確にします。 アーキテクチャ全体図 リポジトリ構成 Terraform vs Lambrollの責任境界 リソース配置のルール エイリアス管理の実際 システム全体図アーキテクチャ概要 主要コンポーネント: GitHub Organization（2リポジトリ） terraform-infrastructure: インフラ管理 lambda-applications: Lambda関数管理 AWS Account Terraform管理リソース（VPC、IAM、RDS等） Lambda Functions + Versions + Aliases S3（アーティファクト保管） 連携 Terraform outputs → 環境変数 → Lambroll CI/CDフロー 3つのフェーズ: Development Flow: コミット → 自動デプロイ → staging環境 Release Flow: 手動承認 → production環境 Canary Release: 段階的トラフィック制御（10% → 100%） リポジトリ構成terraform-infrastructure（インフラリポジトリ）12345678910111213141516171819202122232425262728293031323334353637383940414243444546terraform-infrastructure/├── .github/workflows/│ ├── terraform-plan.yml # PR時: plan実行│ └── terraform-apply.yml # main merge時: apply実行│├── environments/│ ├── production/│ │ ├── backend.tf│ │ ├── terraform.tfvars│ │ └── main.tf│ ├── staging/│ └── development/│├── modules/│ ├── vpc/│ ├── rds/│ ├── lambda-role/│ └── lambda-layer/ # LayerのARN管理│├── iam/│ ├── lambda-roles.tf # Lambda実行ロール│ └── outputs.tf│├── vpc/│ ├── main.tf│ ├── subnets.tf│ ├── security-groups.tf│ └── outputs.tf│├── data-stores/│ ├── rds.tf│ ├── dynamodb.tf│ └── s3.tf│├── messaging/│ ├── sqs.tf│ ├── sns.tf│ └── eventbridge.tf│├── layers/ # Lambda Layer管理│ ├── dependencies/│ │ └── layer.tf│ └── company-utils/│ └── layer.tf│└── outputs.tf # 全体のoutput定義 Terraformの責任: インフラストラクチャ全般 Lambda Layer（ARNのみ） outputs経由でLambrollに情報提供 lambda-applications（アプリケーションリポジトリ）12345678910111213141516171819202122lambda-applications/├── .github/workflows/│ ├── deploy-staging.yml # mainへのpush → staging自動デプロイ│ ├── deploy-production.yml # 手動承認 → production│ └── cleanup-versions.yml # 週次: 古いVersion削除│├── functions/│ ├── user-auth/│ │ ├── function.jsonl # Lambroll設定│ │ ├── index.py # 関数コード│ │ ├── requirements.txt│ │ └── tests/│ ├── order-processing/│ │ ├── function.jsonl│ │ └── index.py│ └── payment-service/│├── scripts/│ ├── cleanup-old-versions.py # Version削除スクリプト│ └── canary-release.sh # カナリアリリース│└── README.md Lambrollの責任: Lambda関数のコードとfunction.jsonl エイリアス管理 デプロイ・バージョン発行 各コンポーネントの責任範囲Terraform: インフラの真実の源泉管理対象 カテゴリ リソース 理由 ネットワーク VPC、Subnet、Security Group インフラ基盤 IAM Lambda実行Role、Policy セキュリティ重要 データストア RDS、DynamoDB（共有）、S3 複数サービスで使用 メッセージング SQS/SNS（共有）、EventBridge 複数サービスで使用 Layer Lambda Layer（ARN管理） 依存関係の一元管理 シークレット Secrets Manager セキュリティ重要 Terraform outputs（Lambrollへの情報提供）12345678910111213141516171819202122232425262728293031323334353637383940# outputs.tf# IAMoutput &quot;lambda_role_arn&quot; { description = &quot;Lambda execution role ARN&quot; value = aws_iam_role.lambda_execution.arn}# VPCoutput &quot;private_subnet_ids&quot; { description = &quot;Private subnet IDs for Lambda&quot; value = aws_subnet.private[*].id}output &quot;lambda_security_group_ids&quot; { description = &quot;Security group IDs for Lambda&quot; value = [aws_security_group.lambda.id]}# RDSoutput &quot;rds_endpoint&quot; { description = &quot;RDS endpoint&quot; value = aws_db_instance.main.endpoint sensitive = true}# Lambda Layeroutput &quot;layer_arns&quot; { description = &quot;Lambda Layer ARNs&quot; value = { dependencies = aws_lambda_layer_version.dependencies.arn company_utils = aws_lambda_layer_version.company_utils.arn }}# S3output &quot;artifact_bucket&quot; { description = &quot;S3 bucket for Lambda artifacts&quot; value = aws_s3_bucket.artifacts.id} Lambroll: Lambda関数に特化管理対象 Lambda関数のコード function.jsonl（関数設定） エイリアス（development、staging、production） function.jsonl の構造12345678910111213141516171819{ &quot;FunctionName&quot;: &quot;user-auth-function&quot;, &quot;Runtime&quot;: &quot;python3.11&quot;, &quot;Handler&quot;: &quot;index.handler&quot;, &quot;MemorySize&quot;: 512, &quot;Timeout&quot;: 30, &quot;Role&quot;: &quot;{{ must_env `TF_ROLE_ARN` }}&quot;, &quot;Layers&quot;: {{ env `TF_LAYER_ARNS` | json_array }}, &quot;VpcConfig&quot;: { &quot;SubnetIds&quot;: {{ env `TF_SUBNET_IDS` | json_array }}, &quot;SecurityGroupIds&quot;: {{ env `TF_SG_IDS` | json_array }} }, &quot;Environment&quot;: { &quot;Variables&quot;: { &quot;DB_ENDPOINT&quot;: &quot;{{ must_env `TF_RDS_ENDPOINT` }}&quot;, &quot;LOG_LEVEL&quot;: &quot;INFO&quot; } }} ポイント: {{ must_env }}: 環境変数から必須値を取得 {{ env }}: 環境変数から任意値を取得 | json_array: 配列に変換 GitHub Actions: CI/CDパイプラインStaging自動デプロイ1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# .github/workflows/deploy-staging.ymlname: Deploy to Stagingon: push: branches: [main] paths: - 'functions/**'jobs: deploy: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 # Terraform outputsを取得 - name: Get Terraform outputs run: | cd ../terraform-infrastructure terraform output -json &gt; outputs.json # 環境変数に設定 echo &quot;TF_ROLE_ARN=$(jq -r '.lambda_role_arn.value' outputs.json)&quot; &gt;&gt; $GITHUB_ENV echo &quot;TF_SUBNET_IDS=$(jq -r '.private_subnet_ids.value | @json' outputs.json)&quot; &gt;&gt; $GITHUB_ENV echo &quot;TF_SG_IDS=$(jq -r '.lambda_security_group_ids.value | @json' outputs.json)&quot; &gt;&gt; $GITHUB_ENV # Lambrollデプロイ - name: Deploy with Lambroll run: | cd functions/user-auth lambroll deploy --log-level info # Versionを発行 - name: Publish Version id: version run: | VERSION=$(aws lambda publish-version \\ --function-name user-auth-function \\ --description &quot;Commit: ${{ github.sha }}&quot; \\ --query 'Version' --output text) echo &quot;version=$VERSION&quot; &gt;&gt; $GITHUB_OUTPUT # staging エイリアスを更新 - name: Update staging alias run: | aws lambda update-alias \\ --function-name user-auth-function \\ --name staging \\ --function-version ${{ steps.version.outputs.version }} Production手動リリース1234567891011121314151617181920212223242526272829# .github/workflows/deploy-production.ymlname: Release to Productionon: workflow_dispatch: inputs: function_name: description: 'Function name' required: true version: description: 'Version number to release' required: truejobs: release: runs-on: ubuntu-latest environment: production # 手動承認が必要 steps: - name: Update production alias run: | aws lambda update-alias \\ --function-name ${{ inputs.function_name }} \\ --name production \\ --function-version ${{ inputs.version }} - name: Notify Slack run: | # Slack通知処理 リソース配置のルール判断フローチャートQ1: 変更頻度は？ 週1回以上 → Q2へ 月1回以下 → Terraform Q2: 共有されるか？ 複数サービスで使用 → Terraform Lambda専用 → Lambroll Q3: セキュリティ重要度は？ 高い → Terraform 普通 → Lambroll リソース配置マトリックス リソース 配置 理由 IAMロール Terraform セキュリティ、共有 VPC/Subnet/SG Terraform インフラ基盤 RDS/DynamoDB(共有) Terraform 複数サービスで使用 S3(共有) Terraform 複数サービスで使用 Secrets Manager Terraform セキュリティ EventBridge Pipes Terraform 共有、監視重要 SQS/SNS(共有) Terraform 複数サービスで使用 Lambda関数 Lambroll 頻繁に変更 Lambda Layer Terraform 依存関係の一元管理 SQS/SNS(専用) Lambroll 関数と密結合 EventBridge(専用) Lambroll 関数と密結合 注意: Layerについて LayerはTerraformで管理します。理由: 変更頻度が低い（依存関係の更新は月1回程度） 複数の関数で共有される ARNをoutputsで提供 → Lambrollが参照 エイリアス管理戦略エイリアス構成の実際123456789101112user-auth-function│├── Versions│ ├── $LATEST│ ├── 1, 2, 3, ..., 14│ ├── 15（現在の production）│ └── 16（最新、staging で検証中）│└── Aliases ├── development → $LATEST ├── staging → 16 └── production → 15 各環境のエイリアス戦略Development12345# 常に $LATEST を参照aws lambda create-alias \\ --function-name user-auth-function \\ --name development \\ --function-version '$LATEST' 特徴: 最新コードを即座に反映 不安定でも問題なし デバッグ用 Staging1234567# デプロイ時に自動更新VERSION=$(aws lambda publish-version ...)aws lambda update-alias \\ --function-name user-auth-function \\ --name staging \\ --function-version $VERSION 特徴: mainへのpushで自動更新 QA・統合テスト用 本番リリース前の最終確認 Production12345# 手動承認後に更新aws lambda update-alias \\ --function-name user-auth-function \\ --name production \\ --function-version 16 特徴: 手動承認が必須 エンドユーザー向け 最も慎重に管理 カナリアリリース（段階的展開）123456789101112131415# Phase 1: 10%のトラフィックを新バージョンにaws lambda update-alias \\ --function-name user-auth-function \\ --name production \\ --function-version 16 \\ --routing-config AdditionalVersionWeights={15=0.9}# 10分間監視sleep 600# Phase 2: 問題なければ100%にaws lambda update-alias \\ --function-name user-auth-function \\ --name production \\ --function-version 16 連携メカニズムTerraform → Lambroll の情報伝達1. Terraform outputsを出力 12cd terraform-infrastructureterraform output -json &gt; outputs.json 2. 環境変数に設定 123export TF_ROLE_ARN=$(jq -r '.lambda_role_arn.value' outputs.json)export TF_SUBNET_IDS=$(jq -r '.private_subnet_ids.value | @json' outputs.json)export TF_LAYER_ARNS=$(jq -r '.layer_arns.value | to_entries | map(.value) | @json' outputs.json) 3. Lambrollがfunction.jsonlで参照 1234{ &quot;Role&quot;: &quot;{{ must_env `TF_ROLE_ARN` }}&quot;, &quot;Layers&quot;: {{ env `TF_LAYER_ARNS` | json_array }}} メリット: SSM Parameter Store不要 シンプルで高速 Terraformが単一の真実の源泉 まとめ責任範囲の明確化 コンポーネント 責任 変更頻度 管理チーム Terraform インフラ全般 低 インフラチーム Lambroll Lambda関数 高 アプリチーム GitHub Actions CI/CD 中 両チーム 連携の要点 Terraform outputsが橋渡し役 stagingは自動、productionは手動 エイリアスで環境を完全分離 バージョンは不変、ロールバック容易 次のステップ構成要素を理解したら、実装の詳細に進みましょう。 次へ: 3. 実装ガイドライン","link":"/2025/11/02/lambda-cicd-02-components/"},{"title":"Lambda CI&#x2F;CD アーキテクチャ - 4. トレードオフと運用上の考慮点","text":"ドキュメント構成 1. CI/CD環境構築における方針 2. 構成要素と役割 3. 実装ガイドライン → 4. トレードオフと運用上の考慮点 免責事項本記事はAI(Claude)を活用して執筆しています。内容の正確性については保証いたしかねますので、重要な情報は必ず一次情報源をご確認ください。 この章で理解することこのアーキテクチャの現実的な評価と、採用判断に必要な情報を提供します。 メリット・デメリット 適用すべき規模と環境 よくある失敗パターン 段階的な導入戦略 FAQ メリット・デメリット メリット1. デプロイ速度の劇的な向上実測値（50関数の環境）: デプロイ時間: 15分 → 2分（87%削減） デプロイ頻度: 週2回 → 日5回（17倍） 理由: Terraformの実行が不要（インフラ変更時のみ） Lambrollは関数のみデプロイ（高速） 並列デプロイ可能 2. 本番障害リスクの最小化エイリアス戦略による保護: staging環境で十分な検証 手動承認により意図しないリリースを防止 カナリアリリース（10% → 100%）で影響範囲を制御 実績: 本番障害: 月1回 → 四半期1回 ロールバック時間: 10分 → 5秒（120倍高速化） 3. チーム間の責任分離明確な境界: インフラチーム → Terraform（インフラ全般） アプリチーム → Lambroll（Lambda関数） 効果: コンフリクト削減 レビュー速度向上 オンボーディング容易化 4. ロールバックの確実性バージョン不変性: 過去の全バージョンが保持される エイリアス切替のみで瞬時にロールバック 監査証跡が残る デメリット1. 初期構築コスト学習コスト: Lambrollの習得（ただしドキュメントは簡潔） Terraform outputsの連携方法 エイリアス管理の理解 構築時間: 初回構築: 約2-3週間 既存環境からの移行: 約1-2ヶ月 2. リポジトリ管理の複雑化2リポジトリ運用: terraform-infrastructure lambda-applications 課題: リポジトリ間の連携（GitHub Actions） outputsの同期 ドキュメントの分散 対策: monorepo化の検討（規模次第） 明確なドキュメント整備 3. バージョン管理の手間Lambda Versionの増加: デプロイごとにVersion作成 コードストレージ上限（75GB/リージョン）に到達リスク 対策: 週次で古いVersionを自動削除 エイリアス保護により安全に削除 4. Lambrollの限定的なエコシステムSAMとの比較: SAM: AWS公式、豊富なドキュメント、大規模コミュニティ Lambroll: サードパーティ、限定的なドキュメント 懸念: 長期的なメンテナンス 新機能への対応速度 トラブル時の情報不足 現実的な評価: 機能はシンプルで安定 AWS APIを直接利用（依存度は低い） 必要ならSAMへの移行も可能 適用すべき規模と環境 このアーキテクチャが最適環境特性: Lambda関数: 20個以上 デプロイ頻度: 週5回以上 チーム規模: 3人以上 本番環境: ダウンタイム許容不可 インフラとアプリの分業: 必要 ユースケース: マイクロサービスアーキテクチャ イベント駆動アーキテクチャ サーバーレスAPI（API Gateway + Lambda） 大規模なバッチ処理 オーバーエンジニアリング環境特性: Lambda関数: 10個未満 デプロイ頻度: 月1-2回 チーム規模: 1-2人 PoC・検証環境 推奨: Terraformのみで十分 CI/CDも最小限（terraform apply） 境界線上（慎重に判断）Lambda関数: 10-20個 判断基準: デプロイ頻度が高い → このアーキテクチャ チーム分業が必要 → このアーキテクチャ 単純な構成 → Terraformのみ よくある失敗パターン失敗例1: エイリアス管理の不徹底問題: 1234# 悪い例: AutoPublishAlias（SAM時代の名残）AutoPublishAlias: live# 結果: デプロイ = リリース（本番に即反映） 対策: 123# 良い例: エイリアスは手動管理# staging: GitHub Actionsで自動更新# production: 手動承認後に更新 学び: エイリアスの自動更新は staging のみ production は必ず手動承認 失敗例2: Terraform outputsの参照忘れ問題: 123456// 悪い例: ハードコード{ &quot;Role&quot;: &quot;arn:aws:iam::123456789012:role/lambda-role&quot;}// 結果: Terraform変更が反映されない 対策: 1234// 良い例: 環境変数で参照{ &quot;Role&quot;: &quot;{{ must_env `TF_ROLE_ARN` }}&quot;} 学び: すべてのインフラ情報はTerraform outputs経由 ハードコードは絶対にしない 失敗例3: バージョン削除の失敗問題: 12345# 悪い例: エイリアス保護なしfor version in all_versions: delete_version(version)# 結果: productionエイリアスが参照するVersionを削除 対策: 12345# 良い例: エイリアス保護protected_versions = get_alias_versions()for version in all_versions: if version not in protected_versions: delete_version(version) 学び: エイリアスが参照するVersionは削除禁止 削除スクリプトは慎重にテスト 失敗例4: Layer管理の分散問題: 123456# 悪い例: LambrollでLayer管理lambda-applications/layers/# 結果: - Terraform outputsとの整合性が取れない- 複数関数で共有しづらい 対策: 1234# 良い例: TerraformでLayer管理terraform-infrastructure/layers/# Lambrollは参照のみ 学び: Layerは変更頻度が低い → Terraform ARNをoutputsで提供 → Lambrollが参照 段階的な導入戦略Phase 1: 小規模で検証（1-2週間）対象: Lambda関数: 1-2個 重要度の低い機能 目標: Terraform + Lambrollの連携確認 エイリアス戦略の検証 CI/CDパイプライン構築 成功基準: staging自動デプロイが動作 production手動リリースが動作 ロールバックが5秒以内 Phase 2: 段階的拡大（1-2ヶ月）対象: Lambda関数: 5-10個 複数チームで利用 目標: チーム間の責任分離を確立 ドキュメント整備 トラブルシューティング手順の確立 成功基準: 複数チームが独立してデプロイ可能 障害時のロールバックが確実 Phase 3: 全面展開（2-3ヶ月）対象: 全Lambda関数 全チーム 目標: 標準CI/CDパイプラインとして確立 運用自動化（バージョン削除等） メトリクス収集と改善 よくある質問（FAQ）Q1: SAMではなくLambrollを選んだ理由は？A: 責任分離の明確化とシンプルさ 観点 SAM Lambroll インフラ管理 あり（重複） なし（明確） Terraform連携 間接的（SSM） 直接的（outputs） 実行速度 遅い（CFn） 速い（API直接） 学習コスト 高い 低い Lambrollは「Lambda関数のみ」に特化しており、Terraformとの責任分離が明確です。 Q2: Lambda Layerは誰が管理すべき？A: Terraformで管理（推奨） 理由: 変更頻度が低い（月1回以下） 複数の関数で共有される ARNをoutputsで提供すればLambrollから参照可能 例外: 特定関数専用のLayer → Lambrollでも可 ただし、Terraformで統一する方がシンプル Q3: バージョンはどれくらい保持すべき？A: 最新10個 + 90日以内 + エイリアス参照中 保持ルール: エイリアス（development、staging、production）が参照中 → 必ず保持 最新10個 → 保持（ロールバック用） 90日以内に作成 → 保持（監査用） 上記以外 → 削除 コードストレージ上限対策: 50関数 × 10バージョン = 500バージョン 1関数あたり50MB → 25GB（上限75GBの1/3） Q4: カナリアリリースは必須？A: 規模と重要度による 必須ケース: ユーザー影響が大きい（決済、認証等） トラフィックが多い（1000 req/sec以上） 過去に本番障害経験あり 不要ケース: 社内ツール バッチ処理（定期実行） トラフィックが少ない 推奨: 重要な関数のみカナリア 10% → 10分監視 → 100% Q5: Terraformの実行頻度は？A: 必要な時のみ（週1回以下） 実行タイミング: インフラ変更時（VPC、RDS追加等） IAMポリシー変更時 Layer更新時 新規Lambda関数の初回作成時（関数名だけTerraformで予約） Lambrollの実行頻度: 日5-10回（mainへのpush） Q6: 既存環境から移行するには？A: 段階的移行（2-3ヶ月） ステップ: Week 1-2: Terraform化（インフラのみ） Week 3-4: 1-2関数をLambroll化（検証） Week 5-8: 段階的に全関数を移行 Week 9-12: CI/CD整備、ドキュメント化 注意点: 一度に全移行しない 重要度の低い関数から開始 ロールバック手順を必ず準備 Q7: Lambrollがメンテされなくなったら？A: AWS APIを直接利用しているため影響は限定的 現実的な対応: 短期: forkして自社でメンテ（コードは非常にシンプル） 中期: AWS CLI + シェルスクリプトで代替 長期: SAMやTerraformに移行 Lambrollの依存度は低い: 単なるAWS API のラッパー function.jsonl → API呼び出しの変換のみ Q8: コストは増えますか？A: GitHub Actions実行時間が増えるが、わずか コスト増: GitHub Actions実行時間: 月500分 → 800分（+60%） 金額: 約$0（無料枠内） コスト減: デプロイ失敗による手戻り削減 障害対応時間の削減 人件費削減（自動化） 結論: 実質的なコスト増はほぼゼロ Q9: Lambda以外のサーバーレスリソースは？A: 基本的にTerraformで管理 例: API Gateway: Terraform（複雑な設定、複数Lambda連携） Step Functions: Terraform（ワークフロー定義） EventBridge: ケースバイケース 共有Rule → Terraform 特定関数専用 → Lambroll（または Terraform） DynamoDB: Terraform（データストア） 原則: 共有リソース → Terraform Q10: チーム構成のベストプラクティスは？A: インフラ1-2名、アプリ3-5名 役割分担: チーム 責任 リポジトリ インフラ VPC、IAM、RDS、Layer terraform-infrastructure アプリ Lambda関数、ビジネスロジック lambda-applications コミュニケーション: 週1回: outputsの確認 Terraform変更時: アプリチームに事前通知 Slack連携: デプロイ通知 まとめこのアーキテクチャの本質エイリアスによる環境分離 + ツールの責任分離 1速度（Lambroll） × 安全性（エイリアス） = 最適なCI/CD 採用判断のチェックリスト Lambda関数が20個以上ある 週5回以上デプロイする チームが3人以上いる インフラとアプリの分業が必要 本番障害リスクを最小化したい ロールバックを高速化したい 3つ以上当てはまる → 採用を検討 次のアクション 小規模で検証: 1-2関数で試す チームで議論: メリット・デメリットを共有 段階的導入: Phase 1から開始 さらに学ぶ公式ドキュメント Terraform Lambda Provider Lambroll GitHub AWS Lambda Versions and Aliases 参考記事 1. CI/CD環境構築における方針（原理原則） 2. 構成要素と役割（全体像） 3. 実装ガイドライン（実装手順） シリーズ完お疲れ様でした！このアーキテクチャが、あなたのチームのLambda運用を改善する一助となれば幸いです。 質問やフィードバックは、ブログコメントまたはTwitter（@yourhandle）までお願いします。 目次に戻る","link":"/2025/11/02/lambda-cicd-04-tradeoffs/"},{"title":"Lambda CI&#x2F;CD アーキテクチャ - 3. 実装ガイドライン","text":"ドキュメント構成 1. CI/CD環境構築における方針 2. 構成要素と役割 → 3. 実装ガイドライン 4. トレードオフと運用上の考慮点 免責事項本記事はAI(Claude)を活用して執筆しています。内容の正確性については保証いたしかねますので、重要な情報は必ず一次情報源をご確認ください。 この章で理解すること実際に構築する際の具体的な手順とコード例を示します。 Terraform実装（インフラ、outputs） Lambda Layer管理 Lambroll実装（function.jsonl、デプロイ） GitHub Actions設定 バージョン削除の自動化 アーティファクト管理 Phase 1: Terraform実装IAMロール作成12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# iam/lambda-roles.tfresource &quot;aws_iam_role&quot; &quot;lambda_execution&quot; { name = &quot;lambda-execution-role&quot; assume_role_policy = jsonencode({ Version = &quot;2012-10-17&quot; Statement = [{ Effect = &quot;Allow&quot; Principal = { Service = &quot;lambda.amazonaws.com&quot; } Action = &quot;sts:AssumeRole&quot; }] })}# 基本的な実行権限resource &quot;aws_iam_role_policy_attachment&quot; &quot;lambda_basic&quot; { role = aws_iam_role.lambda_execution.name policy_arn = &quot;arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole&quot;}# CloudWatch Logsresource &quot;aws_iam_role_policy&quot; &quot;lambda_logging&quot; { name = &quot;lambda-logging&quot; role = aws_iam_role.lambda_execution.id policy = jsonencode({ Version = &quot;2012-10-17&quot; Statement = [{ Effect = &quot;Allow&quot; Action = [ &quot;logs:CreateLogGroup&quot;, &quot;logs:CreateLogStream&quot;, &quot;logs:PutLogEvents&quot; ] Resource = &quot;arn:aws:logs:*:*:*&quot; }] })}# RDSアクセス（必要に応じて）resource &quot;aws_iam_role_policy&quot; &quot;lambda_rds&quot; { name = &quot;lambda-rds-access&quot; role = aws_iam_role.lambda_execution.id policy = jsonencode({ Version = &quot;2012-10-17&quot; Statement = [{ Effect = &quot;Allow&quot; Action = [ &quot;rds-db:connect&quot; ] Resource = aws_db_instance.main.arn }] })} VPC設定123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# vpc/main.tfresource &quot;aws_vpc&quot; &quot;main&quot; { cidr_block = &quot;10.0.0.0/16&quot; enable_dns_hostnames = true enable_dns_support = true tags = { Name = &quot;lambda-vpc&quot; }}resource &quot;aws_subnet&quot; &quot;private&quot; { count = 2 vpc_id = aws_vpc.main.id cidr_block = &quot;10.0.${count.index + 1}.0/24&quot; availability_zone = data.aws_availability_zones.available.names[count.index] tags = { Name = &quot;lambda-private-${count.index + 1}&quot; }}resource &quot;aws_security_group&quot; &quot;lambda&quot; { name = &quot;lambda-sg&quot; description = &quot;Security group for Lambda functions&quot; vpc_id = aws_vpc.main.id # アウトバウンドは全許可（インターネットアクセス用） egress { from_port = 0 to_port = 0 protocol = &quot;-1&quot; cidr_blocks = [&quot;0.0.0.0/0&quot;] } # インバウンドはRDSからのみ（必要に応じて） ingress { from_port = 0 to_port = 0 protocol = &quot;-1&quot; security_groups = [aws_security_group.rds.id] } tags = { Name = &quot;lambda-sg&quot; }} Lambda Layer管理12345678910111213141516171819202122232425# layers/dependencies/layer.tf# 依存関係Layer（pip install等）resource &quot;aws_lambda_layer_version&quot; &quot;dependencies&quot; { layer_name = &quot;common-dependencies&quot; filename = &quot;${path.module}/dependencies.zip&quot; source_code_hash = filebase64sha256(&quot;${path.module}/dependencies.zip&quot;) compatible_runtimes = [&quot;python3.11&quot;] lifecycle { create_before_destroy = true }}# 社内共通ユーティリティLayerresource &quot;aws_lambda_layer_version&quot; &quot;company_utils&quot; { layer_name = &quot;company-utils&quot; filename = &quot;${path.module}/company-utils.zip&quot; source_code_hash = filebase64sha256(&quot;${path.module}/company-utils.zip&quot;) compatible_runtimes = [&quot;python3.11&quot;] lifecycle { create_before_destroy = true }} Layer作成スクリプト: 123456#!/bin/bash# layers/dependencies/build.shmkdir -p pythonpip install -r requirements.txt -t python/zip -r dependencies.zip python/ アーティファクト保管用S3123456789101112131415161718192021222324252627# data-stores/s3.tfresource &quot;aws_s3_bucket&quot; &quot;artifacts&quot; { bucket = &quot;company-lambda-artifacts&quot;}resource &quot;aws_s3_bucket_versioning&quot; &quot;artifacts&quot; { bucket = aws_s3_bucket.artifacts.id versioning_configuration { status = &quot;Enabled&quot; }}# ライフサイクルポリシー（90日以上前のバージョンを削除）resource &quot;aws_s3_bucket_lifecycle_configuration&quot; &quot;artifacts&quot; { bucket = aws_s3_bucket.artifacts.id rule { id = &quot;delete-old-versions&quot; status = &quot;Enabled&quot; noncurrent_version_expiration { noncurrent_days = 90 } }} Terraform outputs1234567891011121314151617181920212223242526272829303132333435# outputs.tfoutput &quot;lambda_role_arn&quot; { description = &quot;Lambda execution role ARN&quot; value = aws_iam_role.lambda_execution.arn}output &quot;private_subnet_ids&quot; { description = &quot;Private subnet IDs for Lambda&quot; value = aws_subnet.private[*].id}output &quot;lambda_security_group_ids&quot; { description = &quot;Security group IDs for Lambda&quot; value = [aws_security_group.lambda.id]}output &quot;rds_endpoint&quot; { description = &quot;RDS endpoint&quot; value = aws_db_instance.main.endpoint sensitive = true}output &quot;layer_arns&quot; { description = &quot;Lambda Layer ARNs&quot; value = { dependencies = aws_lambda_layer_version.dependencies.arn company_utils = aws_lambda_layer_version.company_utils.arn }}output &quot;artifact_bucket&quot; { description = &quot;S3 bucket for Lambda artifacts&quot; value = aws_s3_bucket.artifacts.id} Phase 2: Lambroll実装function.jsonl作成1234567891011121314151617181920212223242526// functions/user-auth/function.jsonl{ &quot;FunctionName&quot;: &quot;user-auth-function&quot;, &quot;Description&quot;: &quot;User authentication handler&quot;, &quot;Runtime&quot;: &quot;python3.11&quot;, &quot;Handler&quot;: &quot;index.handler&quot;, &quot;MemorySize&quot;: 512, &quot;Timeout&quot;: 30, &quot;Role&quot;: &quot;{{ must_env `TF_ROLE_ARN` }}&quot;, &quot;Layers&quot;: {{ env `TF_LAYER_ARNS` | json_array }}, &quot;VpcConfig&quot;: { &quot;SubnetIds&quot;: {{ env `TF_SUBNET_IDS` | json_array }}, &quot;SecurityGroupIds&quot;: {{ env `TF_SG_IDS` | json_array }} }, &quot;Environment&quot;: { &quot;Variables&quot;: { &quot;DB_ENDPOINT&quot;: &quot;{{ must_env `TF_RDS_ENDPOINT` }}&quot;, &quot;LOG_LEVEL&quot;: &quot;INFO&quot;, &quot;ENVIRONMENT&quot;: &quot;{{ env `ENVIRONMENT` | default `development` }}&quot; } }, &quot;Tags&quot;: { &quot;ManagedBy&quot;: &quot;Lambroll&quot;, &quot;Team&quot;: &quot;Backend&quot; }} Lambda関数コード123456789101112131415161718192021222324252627282930313233343536# functions/user-auth/index.pyimport jsonimport osimport logging# 環境変数から設定取得DB_ENDPOINT = os.environ['DB_ENDPOINT']LOG_LEVEL = os.environ.get('LOG_LEVEL', 'INFO')logger = logging.getLogger()logger.setLevel(LOG_LEVEL)def handler(event, context): &quot;&quot;&quot; ユーザー認証のハンドラー &quot;&quot;&quot; logger.info(f&quot;Received event: {json.dumps(event)}&quot;) try: # ビジネスロジック result = authenticate_user(event) return { 'statusCode': 200, 'body': json.dumps(result) } except Exception as e: logger.error(f&quot;Error: {str(e)}&quot;, exc_info=True) return { 'statusCode': 500, 'body': json.dumps({'error': 'Internal server error'}) }def authenticate_user(event): # 認証ロジック return {'authenticated': True} エイリアス初期設定12345678910111213141516171819# 初回のみ実行: エイリアスを作成# developmentaws lambda create-alias \\ --function-name user-auth-function \\ --name development \\ --function-version '$LATEST'# staging（初期はVersion 1を参照）aws lambda create-alias \\ --function-name user-auth-function \\ --name staging \\ --function-version 1# production（初期はVersion 1を参照）aws lambda create-alias \\ --function-name user-auth-function \\ --name production \\ --function-version 1 Phase 3: GitHub Actions設定Terraform CI/CD1234567891011121314151617181920212223242526272829303132333435363738394041# terraform-infrastructure/.github/workflows/terraform-apply.ymlname: Terraform Applyon: push: branches: [main] paths: - '**.tf' - 'environments/**'jobs: terraform: runs-on: ubuntu-latest permissions: id-token: write contents: read steps: - uses: actions/checkout@v4 - uses: hashicorp/setup-terraform@v3 with: terraform_version: 1.6.0 - uses: aws-actions/configure-aws-credentials@v4 with: role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE_ARN }} aws-region: ap-northeast-1 - name: Terraform Init run: terraform init working-directory: environments/production - name: Terraform Plan run: terraform plan -out=tfplan working-directory: environments/production - name: Terraform Apply run: terraform apply tfplan working-directory: environments/production Lambroll Staging自動デプロイ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106# lambda-applications/.github/workflows/deploy-staging.ymlname: Deploy to Stagingon: push: branches: [main] paths: - 'functions/**'jobs: deploy: runs-on: ubuntu-latest permissions: id-token: write contents: read steps: - uses: actions/checkout@v4 - uses: aws-actions/configure-aws-credentials@v4 with: role-to-assume: ${{ secrets.AWS_LAMBDA_ROLE_ARN }} aws-region: ap-northeast-1 # Terraform outputsを取得 - name: Checkout infrastructure repo uses: actions/checkout@v4 with: repository: your-org/terraform-infrastructure path: terraform-infrastructure token: ${{ secrets.GH_TOKEN }} - name: Get Terraform outputs id: tf_outputs run: | cd terraform-infrastructure/environments/production terraform init -backend-config=backend.hcl terraform output -json &gt; outputs.json # 環境変数に設定 echo &quot;TF_ROLE_ARN=$(jq -r '.lambda_role_arn.value' outputs.json)&quot; &gt;&gt; $GITHUB_ENV echo &quot;TF_SUBNET_IDS=$(jq -r '.private_subnet_ids.value | @json' outputs.json)&quot; &gt;&gt; $GITHUB_ENV echo &quot;TF_SG_IDS=$(jq -r '.lambda_security_group_ids.value | @json' outputs.json)&quot; &gt;&gt; $GITHUB_ENV echo &quot;TF_RDS_ENDPOINT=$(jq -r '.rds_endpoint.value' outputs.json)&quot; &gt;&gt; $GITHUB_ENV # Layer ARNs LAYERS=$(jq -r '.layer_arns.value | to_entries | map(.value) | @json' outputs.json) echo &quot;TF_LAYER_ARNS=$LAYERS&quot; &gt;&gt; $GITHUB_ENV # Lambrollインストール - name: Setup Lambroll run: | VERSION=&quot;1.0.3&quot; curl -L &quot;https://github.com/fujiwara/lambroll/releases/download/v${VERSION}/lambroll_${VERSION}_linux_amd64.tar.gz&quot; | tar xz sudo mv lambroll /usr/local/bin/ lambroll version # デプロイ - name: Deploy with Lambroll run: | cd functions/user-auth lambroll deploy --log-level info env: ENVIRONMENT: staging # Versionを発行 - name: Publish Version id: version run: | VERSION=$(aws lambda publish-version \\ --function-name user-auth-function \\ --description &quot;Commit: ${{ github.sha }}, Actor: ${{ github.actor }}&quot; \\ --query 'Version' \\ --output text) echo &quot;version=$VERSION&quot; &gt;&gt; $GITHUB_OUTPUT echo &quot;Published version: $VERSION&quot; # staging エイリアス更新 - name: Update staging alias run: | aws lambda update-alias \\ --function-name user-auth-function \\ --name staging \\ --function-version ${{ steps.version.outputs.version }} echo &quot;Deployed to staging: version ${{ steps.version.outputs.version }}&quot; # Slack通知 - name: Notify Slack if: always() uses: slackapi/slack-github-action@v1 with: webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }} payload: | { &quot;text&quot;: &quot;Staging Deployment&quot;, &quot;blocks&quot;: [ { &quot;type&quot;: &quot;section&quot;, &quot;text&quot;: { &quot;type&quot;: &quot;mrkdwn&quot;, &quot;text&quot;: &quot;*Deployment Status:* ${{ job.status }}\\n*Function:* user-auth-function\\n*Version:* ${{ steps.version.outputs.version }}\\n*Commit:* ${{ github.sha }}&quot; } } ] } Production手動リリース12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# lambda-applications/.github/workflows/deploy-production.ymlname: Release to Productionon: workflow_dispatch: inputs: function_name: description: 'Function name to release' required: true type: choice options: - user-auth-function - order-processing-function - payment-service-function version: description: 'Version number (from staging)' required: truejobs: release: runs-on: ubuntu-latest environment: production # 手動承認が必要 permissions: id-token: write contents: read steps: - uses: aws-actions/configure-aws-credentials@v4 with: role-to-assume: ${{ secrets.AWS_LAMBDA_ROLE_ARN }} aws-region: ap-northeast-1 # バージョン検証 - name: Verify version exists run: | aws lambda get-function \\ --function-name ${{ inputs.function_name }} \\ --qualifier ${{ inputs.version }} # production エイリアス更新 - name: Update production alias run: | aws lambda update-alias \\ --function-name ${{ inputs.function_name }} \\ --name production \\ --function-version ${{ inputs.version }} # 検証 - name: Verify deployment run: | CURRENT=$(aws lambda get-alias \\ --function-name ${{ inputs.function_name }} \\ --name production \\ --query 'FunctionVersion' \\ --output text) if [ &quot;$CURRENT&quot; == &quot;${{ inputs.version }}&quot; ]; then echo &quot;Successfully released version ${{ inputs.version }}&quot; else echo &quot;Release failed. Current: $CURRENT, Expected: ${{ inputs.version }}&quot; exit 1 fi # Slack通知 - name: Notify Slack uses: slackapi/slack-github-action@v1 with: webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }} payload: | { &quot;text&quot;: &quot;Production Release&quot;, &quot;blocks&quot;: [ { &quot;type&quot;: &quot;section&quot;, &quot;text&quot;: { &quot;type&quot;: &quot;mrkdwn&quot;, &quot;text&quot;: &quot;*Function:* ${{ inputs.function_name }}\\n*Version:* ${{ inputs.version }}\\n*Released by:* ${{ github.actor }}&quot; } } ] } Phase 4: バージョン削除の自動化削除スクリプト123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105# scripts/cleanup-old-versions.pyimport boto3from datetime import datetime, timedeltaimport syslambda_client = boto3.client('lambda')def cleanup_old_versions( function_name, keep_versions=10, keep_days=90): &quot;&quot;&quot; 古いLambdaバージョンを削除 保持ルール: - エイリアスが参照しているバージョン - 最新N個のバージョン - N日以内に作成されたバージョン &quot;&quot;&quot; print(f&quot;Processing {function_name}...&quot;) # エイリアスが参照しているバージョンを取得 try: aliases = lambda_client.list_aliases(FunctionName=function_name) protected_versions = set( alias['FunctionVersion'] for alias in aliases['Aliases'] if alias['FunctionVersion'] != '$LATEST' ) print(f&quot; Protected versions (by aliases): {protected_versions}&quot;) except Exception as e: print(f&quot; Error getting aliases: {e}&quot;) return # すべてのバージョンを取得 try: versions = lambda_client.list_versions_by_function( FunctionName=function_name, MaxItems=100 ) except Exception as e: print(f&quot; Error listing versions: {e}&quot;) return # 削除対象を決定 deletable = [] cutoff_date = datetime.now(datetime.timezone.utc) - timedelta(days=keep_days) for version in versions['Versions']: version_num = version['Version'] # スキップ条件 if version_num == '$LATEST': continue if version_num in protected_versions: continue last_modified = datetime.fromisoformat( version['LastModified'].replace('Z', '+00:00') ) if last_modified &lt; cutoff_date: deletable.append({ 'version': version_num, 'last_modified': last_modified }) # 最新N個は保持（日付でソート） deletable.sort(key=lambda x: x['last_modified'], reverse=True) to_delete = deletable[keep_versions:] print(f&quot; Total versions: {len(versions['Versions'])}&quot;) print(f&quot; Deletable (old): {len(deletable)}&quot;) print(f&quot; Will delete: {len(to_delete)}&quot;) # 削除実行 for item in to_delete: version_num = item['version'] try: lambda_client.delete_function( FunctionName=function_name, Qualifier=version_num ) print(f&quot; Deleted version {version_num}&quot;) except Exception as e: print(f&quot; Failed to delete version {version_num}: {e}&quot;)def main(): # すべてのLambda関数を取得 paginator = lambda_client.get_paginator('list_functions') for page in paginator.paginate(): for func in page['Functions']: function_name = func['FunctionName'] cleanup_old_versions( function_name, keep_versions=10, keep_days=90 ) print()if __name__ == '__main__': main() 週次実行ワークフロー123456789101112131415161718192021222324252627282930313233# lambda-applications/.github/workflows/cleanup-versions.ymlname: Cleanup Old Lambda Versionson: schedule: - cron: '0 0 * * 0' # 毎週日曜日 0:00 UTC workflow_dispatch: # 手動実行も可能jobs: cleanup: runs-on: ubuntu-latest permissions: id-token: write contents: read steps: - uses: actions/checkout@v4 - uses: actions/setup-python@v4 with: python-version: '3.11' - name: Install dependencies run: pip install boto3 - uses: aws-actions/configure-aws-credentials@v4 with: role-to-assume: ${{ secrets.AWS_LAMBDA_ROLE_ARN }} aws-region: ap-northeast-1 - name: Run cleanup run: python scripts/cleanup-old-versions.py Phase 5: アーティファクト管理S3へのアップロード12345678910111213# Staging デプロイ前にアーティファクトを保存- name: Build and upload artifact run: | cd functions/user-auth # zipファイル作成 zip -r function.zip index.py requirements.txt # S3にアップロード（バージョニング有効） ARTIFACT_KEY=&quot;user-auth-function/$(date +%Y%m%d-%H%M%S)-${GITHUB_SHA::7}.zip&quot; aws s3 cp function.zip s3://${{ env.TF_ARTIFACT_BUCKET }}/${ARTIFACT_KEY} echo &quot;artifact_key=$ARTIFACT_KEY&quot; &gt;&gt; $GITHUB_OUTPUT ロールバック時の利用123456# 特定バージョンのアーティファクトを取得してデプロイaws s3 cp s3://company-lambda-artifacts/user-auth-function/20250102-120000-abc1234.zip ./function.zip# 展開してLambrollでデプロイunzip function.ziplambroll deploy まとめ実装の流れ Phase 1: Terraform（インフラ、IAM、Layer、outputs） Phase 2: Lambroll（function.jsonl、コード） Phase 3: GitHub Actions（CI/CD、手動承認） Phase 4: バージョン削除（週次自動化） Phase 5: アーティファクト管理（S3保管） チェックリスト Terraform outputsが正しく設定されている Lambrollがoutputsを環境変数で参照できる エイリアス（development、staging、production）が作成済み GitHub Actions環境変数・Secretsが設定済み S3バケット（アーティファクト保管）が作成済み バージョン削除スクリプトが動作する 次のステップ実装方法を理解したら、運用上の考慮点を確認しましょう。 次へ: 4. トレードオフと運用上の考慮点","link":"/2025/11/02/lambda-cicd-03-implementation/"},{"title":"miseでのNodeバージョン管理","text":"mise の設定メモ 環境情報 OS macOS Version 15.5 BuildVersion 24F74 インストール12curl https://mise.run | shecho 'eval &quot;$(~/.local/bin/mise activate zsh)&quot;' &gt;&gt; ~/.zshrc インストール確認1mise doctor Node.jsの設定1234mise ls-remote nodemise use node@22.16.0# グローバルの場合mise use -g node@22.16.0 リポジトリ内でのバージョン指定.mise.toml 12[tools]node = &quot;22.16.0&quot; 1mise install","link":"/2025/06/22/mise/"},{"title":"SlackのIncoming Webhooksについて","text":"自分の知っていたSlackのIncoming-WebhookはLegacyとしてかなり前に非推奨になっていた話。 サポートに関する情報Discontinuing support for legacy custom bots and classic appsによれば 2024年6月: 新しいlegacy appsとclassic appsの作成をブロック開始 2025年3月31日: legacy custom botsのサポート終了 2026年5月25日: classic appsのサポート終了 公開されているスケジュールは上記のもので、Legacy Custom Integrationsにあたる、Legacy Incoming Webhookは明確に期日を決められているわけではなさそうです。色々と仕様の変更については書かれていますが、基本的にはpayloadとして互換性もあるので、ひとまず移行してしまった方が無難という結論です。 Legacy Incoming Webhook と Incoming WebhookLegacy Incoming Webhook Incoming Webhookでアプリを検索すると表示されます We do not recommend their use. という注意書きが上部にあります 設定画面が１画面で完結し、非常にシンプルでわかりやすく設定できます Incoming Webhook Slack AppをにてCreate New Appを選択 From scratchを選択、App Nameとworkspaceを入力してCreate Basic InformationのDisplay Informationを入力 Features &gt; Incoming Webhooks Activate Incoming Webhooks を On にします Add New Webhookで、URLをchannelごとに作成します それぞれの違い Legacy Incoming Webhook ペイロード内でusername、icon、channelを上書きできる URL知ってたらどのchannelでも書き込めるわけで、あまりよくない仕様ですね 作成者が組織を離れるとWebhookが無効化される管理上の問題があります レイアウトはattachmentsで表現します Incoming Webhook レイアウトはBlock Kitを使用してより高度なメッセージ作成が可能です 移行方法はMigrate your legacy message compositions to blocks ただし、attachmentsも非推奨ですが、使えるので互換性は担保されそうです 特に色指定はattachmentsしか表現できず、メッセージの緊急度で色分けしたいケース（監視アラート等）では使うしかありません 色指定にgood/warning/dangerは使えないという情報を見かけましたが、問題なく使えました。カラーコードもOK（例：#ff0000） attachmentsでのテストペイロード 1234567891011curl -X POST -H 'Content-type: application/json' \\ --data '{ &quot;text&quot;: &quot;Hello, World!&quot;, &quot;attachments&quot;: [ { &quot;color&quot;: &quot;good&quot;, &quot;text&quot;: &quot;This is a test message&quot; } ] }' \\ https://{YOUR_WEBHOOK_URL}","link":"/2025/06/25/slack_webhooks/"},{"title":"uvでのpythonバージョン管理と仮想環境管理","text":"uv の設定メモ 環境情報 OS macOS Version 15.5 BuildVersion 24F74 インストール1brew install uv プロジェクト初回設定プロジェクトディレクトリで初期化1uv init pyproject.tomlが生成されるため、pythonバージョンを指定 pyproject.toml 1234567...[project]name = &quot;Project Name&quot;version = &quot;0.1.0&quot;description = &quot;Add your description here&quot;readme = &quot;README.md&quot;requires-python = &quot;&gt;=3.13&quot; requirements.txtの取り込み1uv add -r requirements.txt requirements.txtを取り込んだ後は削除してもOK pyproject.tomlをもとにパッケージをインストール1uv sync dependabot.github/dependabot.yml 123456version: 2updates: - package-ecosystem: &quot;uv&quot; # See documentation for possible values directory: &quot;/&quot; # Location of package manifests schedule: interval: &quot;weekly&quot; .gitignore.gitignore 12345...# uv package manager.uv/uv.lock.uvignore 作業開始時仮想環境を有効化1. .venv/bin/activate 作業終了時仮想環境を無効化1deactivate","link":"/2025/06/22/uv/"},{"title":"zed editorでのBedrock接続（Proxy経由）","text":"zed でAmazon Bedrock接続（Proxy経由）の設定メモ 環境情報 OS macOS Version 15.5 前提 AWS CLIがインストールされ、プロファイル設定が完了していること Bedrockのモデル有効化AWSマネジメントコンソールで利用したいRegionでBedrockの画面へアクセス“Bedrock configurations” &gt; “モデルアクセス” で有効化したいモデルをリクエスト Zed でのBedrockの設定 Authentication via Named Profile (Recommended) Network Proxy Setting.jsonを編集 1234567&quot;language_models&quot;: { &quot;bedrock&quot;: { &quot;authentication_method&quot;: &quot;named_profile&quot;, &quot;region&quot;: &quot;{your-aws-region}}&quot;, &quot;profile&quot;: &quot;{your-profile-name}&quot; },&quot;proxy&quot;: &quot;http://username:password@proxyserver:port&quot; 設定後、必ずZedの再起動が必要","link":"/2025/06/22/zed_bedrock/"},{"title":"zshとbashは違う","text":"jqを使った時に気づいた話 bashはデフォルトで.items[]をリテラルな文字列として扱います。 123# bashecho '{&quot;items&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]}' | jq -r .items[] | xargs echoa b c zshはデフォルトで、クォートされていない引数をグロブパターンとして扱おうとします。 123# zshecho '{&quot;items&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]}' | jq -r .items[] | xargs echozsh: no matches found: .items[] zshでこのコマンドを正しく動作させるには、.items[]をクォートで囲む必要があります。 12echo '{&quot;items&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]}' | jq -r '.items[]' | xargs echoa b c shellcheckを使うと安心Macのインストールは以下のコマンドです 1brew install shellcheck","link":"/2024/09/07/zsh_bash/"}],"tags":[{"name":"Route53","slug":"Route53","link":"/tags/Route53/"},{"name":"DNS","slug":"DNS","link":"/tags/DNS/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"sshd","slug":"sshd","link":"/tags/sshd/"},{"name":"AWS Lambda","slug":"AWS-Lambda","link":"/tags/AWS-Lambda/"},{"name":"CI&#x2F;CD","slug":"CI-CD","link":"/tags/CI-CD/"},{"name":"Terraform","slug":"Terraform","link":"/tags/Terraform/"},{"name":"Lambroll","slug":"Lambroll","link":"/tags/Lambroll/"},{"name":"GitHub Actions","slug":"GitHub-Actions","link":"/tags/GitHub-Actions/"},{"name":"アーキテクチャ","slug":"アーキテクチャ","link":"/tags/%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3/"},{"name":"インフラ","slug":"インフラ","link":"/tags/%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9/"},{"name":"エイリアス","slug":"エイリアス","link":"/tags/%E3%82%A8%E3%82%A4%E3%83%AA%E3%82%A2%E3%82%B9/"},{"name":"運用","slug":"運用","link":"/tags/%E9%81%8B%E7%94%A8/"},{"name":"実装","slug":"実装","link":"/tags/%E5%AE%9F%E8%A3%85/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"mise","slug":"mise","link":"/tags/mise/"},{"name":"Slack","slug":"Slack","link":"/tags/Slack/"},{"name":"uv","slug":"uv","link":"/tags/uv/"},{"name":"Zed","slug":"Zed","link":"/tags/Zed/"},{"name":"Bedrock","slug":"Bedrock","link":"/tags/Bedrock/"},{"name":"zsh","slug":"zsh","link":"/tags/zsh/"},{"name":"bash","slug":"bash","link":"/tags/bash/"}],"categories":[{"name":"DNS","slug":"DNS","link":"/categories/DNS/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"AWS","slug":"AWS","link":"/categories/AWS/"},{"name":"DevOps","slug":"AWS/DevOps","link":"/categories/AWS/DevOps/"},{"name":"Node.js","slug":"Node-js","link":"/categories/Node-js/"},{"name":"Slack","slug":"Slack","link":"/categories/Slack/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"Zed","slug":"Zed","link":"/categories/Zed/"},{"name":"Mac","slug":"Mac","link":"/categories/Mac/"}],"pages":[{"title":"","text":"/* カスタムスタイル - コンテンツ幅を固定して読みやすく */ /* 1200px以上の画面ではコンテンツ幅を1200pxに固定 */ @media screen and (min-width: 1200px) { .is-1-column .container, .is-2-column .container { max-width: 1200px; width: 1200px; } }","link":"/css/custom.css"}]}